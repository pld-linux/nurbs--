--- nurbs++-3.0.11/matrix/matrix_uchar.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/matrix_uchar.cpp	2006-04-14 22:20:06.938397250 +0200
@@ -27,6 +27,7 @@
 
 namespace PLib {
 
+  template<>
   Matrix<unsigned char>&
     Matrix<unsigned char>::operator*=(double a)
     {
@@ -40,6 +41,7 @@
       return *this ;
     }
   
+  template<>
   Matrix<unsigned char>&
     Matrix<unsigned char>::operator+=(double a)
     {
@@ -52,6 +54,7 @@
     }
   
   
+  template<>
   Matrix<unsigned char>&
     Matrix<unsigned char>::operator-=(double a)
     {
@@ -64,6 +67,7 @@
     }
   
   
+  template<>
   Matrix<unsigned char>&
     Matrix<unsigned char>::operator/=(double a)
     {
--- nurbs++-3.0.11/matrix/vector.h.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/vector.h	2006-04-14 21:20:46.155862250 +0200
@@ -69,7 +69,7 @@
   {
   public:
     int rows() const //!< a reference to the size of the vector
-      { return sze ;}
+      { return this->sze ;}
     Vector() : BasicArray<T>(1) {} //!< Basic constructor
     Vector(const int r) : BasicArray<T>(r) {}
     Vector(const Vector<T>& v) : BasicArray<T>(v) {}
--- nurbs++-3.0.11/matrix/vector.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/vector.cpp	2006-04-14 22:08:11.165664250 +0200
@@ -51,16 +51,16 @@
   if(this==&b)
     return *this ;
 
-  if ( n() != b.n())
+  if ( this->n() != b.n())
     {
       resize(b.n()) ;
     }
 
-  sze = b.n() ;
+  this->sze = b.n() ;
   T *pa, *pb ;
-  pa = x-1 ;
+  pa = this->x-1 ;
   pb = b.x-1 ;
-  for(int i=n();i>0;--i){
+  for(int i=this->n();i>0;--i){
     *(++pa) = *(++pb) ;
   }
   return *this;
@@ -79,13 +79,13 @@
 template <class T>
 Vector<T>& Vector<T>::operator=(const BasicArray<T> &b)
 {
-  if ( size() != b.size())
+  if ( this->size() != b.size())
     {
       resize(b.size()) ;
     }
   T *ptr ;
-  ptr = x - 1 ;
-  for(int i=size()-1;i>=0;--i)
+  ptr = this->x - 1 ;
+  for(int i=this->size()-1;i>=0;--i)
      *(++ptr) = b[i] ;
 
   return *this;
@@ -105,9 +105,9 @@
 template <class T>
 T Vector<T>::operator=(const T d)
 {
-  const int sz = size(); 
+  const int sz = this->size(); 
   T *ptr ;
-  ptr = x-1 ;
+  ptr = this->x-1 ;
   for (int i = sz; i > 0; --i)
     *(++ptr) = d ;
 
@@ -130,19 +130,19 @@
 template <class T>
 Vector<T>& Vector<T>::operator+=(const Vector<T> &a)
 {
-  if ( a.size() != size())
+  if ( a.size() != this->size())
     {
 #ifdef USE_EXCEPTION
-      throw WrongSize(size(),a.size()) ;
+      throw WrongSize(this->size(),a.size()) ;
 #else
       Error error("Vector<T>::operator+=(Vector<T>&)");
-      error << "Vector<T> a += Vector<T> b different sizes, a = " << size() << ", b = " << a.size() ;
+      error << "Vector<T> a += Vector<T> b different sizes, a = " << this->size() << ", b = " << a.size() ;
       error.fatal() ;
 #endif
     }
-  const int sz = size();
+  const int sz = this->size();
   T *ptr,*aptr ;
-  ptr = x-1 ;
+  ptr = this->x-1 ;
   aptr = a.x-1 ;
   for (int i = sz; i >0; --i)
     *(++ptr) += *(++aptr) ;
@@ -165,20 +165,20 @@
 template <class T>
 Vector<T>& Vector<T>::operator-=(const Vector<T> &a)
 {
-  if ( a.size() != size())
+  if ( a.size() != this->size())
     {
 #ifdef USE_EXCEPTION
-      throw WrongSize(size(),a.size()) ;
+      throw WrongSize(this->size(),a.size()) ;
 #else
       Error error("Vector<T>::operator-=(Vector<T>&)");
-      error << "Vector<T> a -= Vector<T> b different sizes, a = " << size() << ", b = " << a.size() ;
+      error << "Vector<T> a -= Vector<T> b different sizes, a = " << this->size() << ", b = " << a.size() ;
       error.fatal() ;
 #endif
     }
   
-  const int sz = size(); 
+  const int sz = this->size(); 
   T *ptr,*aptr ;
-  ptr = x-1 ;
+  ptr = this->x-1 ;
   aptr = a.x-1 ;
   for (int i = sz; i > 0; --i)
     *(++ptr) -= *(++aptr) ;
@@ -391,7 +391,7 @@
     }
 
   T *aptr,*bptr ;
-  aptr = &x[i]-1 ;
+  aptr = &this->x[i]-1 ;
   bptr = b.x-1 ;
   for ( int j = b.rows(); j > 0; --j)
       *(++aptr) = *(++bptr) ;
@@ -429,7 +429,7 @@
 
   Vector<T> subvec(l) ;
   T *aptr, *bptr ;
-  aptr = &x[i] - 1 ;
+  aptr = &this->x[i] - 1 ;
   bptr = subvec.x -1 ;
   for ( int j = l; j > 0; --j)
     *(++bptr) = *(++aptr) ;
@@ -449,12 +449,12 @@
 */
 template <class T>
 int Vector<T>::minIndex() const {
-  T min = x[0] ;
+  T min = this->x[0] ;
   int index = 0 ;
 
-  for(int i=1;i<n();i++){
-    if(x[i]<=min){
-      min = x[i] ;
+  for(int i=1;i<this->n();i++){
+    if(this->x[i]<=min){
+      min = this->x[i] ;
       index = i ;
     }
   }
@@ -523,12 +523,12 @@
   T a ;
   T *v1,*v2  ;
 
-  ir = sze-1 ;
+  ir = this->sze-1 ;
   l = 0 ;
   
   while(1){
     if(ir-l<M){ // perform an insertion sort when the array is small enough
-      v1 = &x[l] ;
+      v1 = &this->x[l] ;
       for(j=l+1;j<=ir;++j){
 	a = *(++v1) ;
 	v2 = v1 ;
@@ -547,31 +547,31 @@
     }
     else{
       k=(l+ir) >> 1 ;
-      swap(x[k],x[l+1]) ;
-      if(x[l+1] > x[ir]){
-	swap(x[l+1],x[ir]) ;
+      swap(this->x[k],this->x[l+1]) ;
+      if(this->x[l+1] > this->x[ir]){
+	swap(this->x[l+1],this->x[ir]) ;
       }
-      if(x[l]> x[ir]){
-	swap(x[l],x[ir]) ;
+      if(this->x[l]> this->x[ir]){
+	swap(this->x[l],this->x[ir]) ;
       }
-      if(x[l+1] > x[l]){
-	swap(x[l+1],x[l]) ;
+      if(this->x[l+1] > this->x[l]){
+	swap(this->x[l+1],this->x[l]) ;
       }
       i=l+1 ;
       j=ir ;
-      a=x[l] ;
-      v1 = &x[i] ;
-      v2 = &x[j] ;
+      a=this->x[l] ;
+      v1 = &this->x[i] ;
+      v2 = &this->x[j] ;
       while(1){
 	while(*v1 < a) { ++i ; ++v1 ; }
 	while(*v2 > a) { --j ; --v2 ; }
 	if(j<i) break ;
 	if(*v1 == *v2)  // both are equal to a...
 	  break ;
-	swap(x[i],x[j]) ;
+	swap(this->x[i],this->x[j]) ;
       }
-      x[l] = x[j] ;
-      x[j] = a ;
+      this->x[l] = this->x[j] ;
+      this->x[j] = a ;
       jstack += 2 ;
       if(jstack>=Nstack){
 	istack.resize(istack.n()+Nstack) ; // increase the vector size
@@ -618,10 +618,10 @@
   int jstack=0;
   T a ;
 
-  ir = sze-1 ;
+  ir = this->sze-1 ;
   l = 0 ;
   
-  index.resize(sze) ;
+  index.resize(this->sze) ;
   for(i=0;i<index.n();++i)
     index[i] = i ;
 
@@ -629,9 +629,9 @@
     if(ir-l<M){ // perform an insertion sort when the array is small enough
       for(j=l+1;j<=ir;++j){
 	indext = index[j] ;
-	a = x[indext] ;
+	a = this->x[indext] ;
 	for(i=j-1;i>=0;--i){
-	  if(x[index[i]] <= a) break ;
+	  if(this->x[index[i]] <= a) break ;
 	  index[i+1] = index[i] ;
 	}
 	index[i+1] = indext ;
@@ -643,24 +643,24 @@
     else{
       k=(l+ir) >> 1 ;
       swap(index[k],index[l+1]) ;
-      if(x[index[l+1]] > x[index[ir]]){
+      if(this->x[index[l+1]] > this->x[index[ir]]){
 	swap(index[l+1],index[ir]) ;
       }
-      if(x[index[l]]> x[index[ir]]){
+      if(this->x[index[l]]> this->x[index[ir]]){
 	swap(index[l],index[ir]) ;
       }
-      if(x[index[l+1]] > x[index[l]]){
+      if(this->x[index[l+1]] > this->x[index[l]]){
 	swap(index[l+1],index[l]) ;
       }
       i=l+1 ;
       j=ir ;
       indext = index[l] ;
-      a=x[indext] ;
+      a=this->x[indext] ;
       while(1){
-	while(x[index[i]] < a) { ++i ; }
-	while(x[index[j]] > a) { --j ; }
+	while(this->x[index[i]] < a) { ++i ; }
+	while(this->x[index[j]] > a) { --j ; }
 	if(j<i) break ;
-	if(x[index[i]] == x[index[j]])
+	if(this->x[index[i]] == this->x[index[j]])
 	  break ;
 	swap(index[i],index[j]) ;
       }
--- nurbs++-3.0.11/matrix/cvector.h.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/cvector.h	2006-04-14 21:22:03.036667000 +0200
@@ -54,10 +54,10 @@
     CVector(const BasicArray<T>& v) : Vector<T>(v), index(0)  {;}
     virtual ~CVector() {}
     
-    T& operator[](const int i) { return x[i%sze]; }
-    T  operator[](const int i) const   { return x[i%sze]; }
+    T& operator[](const int i) { return this->x[i%this->sze]; }
+    T  operator[](const int i) const   { return this->x[i%this->sze]; }
     
-    void put(T v) { x[index] = v ; index = (index+1)%sze; }
+    void put(T v) { this->x[index] = v ; index = (index+1)%this->sze; }
     
   protected:
     int index ;
--- nurbs++-3.0.11/matrix/matrix_int.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/matrix_int.cpp	2006-04-14 21:56:53.575317500 +0200
@@ -29,10 +29,12 @@
 
 namespace PLib {
 
+  template<>
   void Matrix<int>::qSort(){
     qsort((char*)m,rows()*cols(),sizeof(int),compareInt) ;
   }
   
+  template<>
   Matrix<int>&
     Matrix<int>::operator*=(double a)
     {
@@ -46,6 +48,7 @@
       return *this ;
     }
   
+  template<>
   Matrix<int>&
     Matrix<int>::operator+=(double a)
     {
@@ -57,6 +60,7 @@
       return *this ;
     }
 
+  template<>
   Matrix<int>&
     Matrix<int>::operator-=(double a)
     {
@@ -68,6 +72,7 @@
       return *this ;
     }
   
+  template<>
   Matrix<int>&
     Matrix<int>::operator/=(double a)
     {
--- nurbs++-3.0.11/matrix/vector_int.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/vector_int.cpp	2006-04-14 22:08:32.931024500 +0200
@@ -27,6 +27,7 @@
 
 namespace PLib {
 
+  template<>
   void Vector<int>::qSortStd(){
     qsort((char*)memory(),n(),sizeof(int),compareInt) ;
   }
--- nurbs++-3.0.11/matrix/matrix.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/matrix.cpp	2006-04-14 21:55:20.841522000 +0200
@@ -54,19 +54,19 @@
   if ( this == &a )
     return *this;
   
-  if ( a.rows() != rows() || a.cols() != cols() ){
+  if ( a.rows() != this->rows() || a.cols() != this->cols() ){
     resize(a.rows(),a.cols()) ;
   }
   
-  int sze = rows()*cols() ;
+  int sze = this->rows()*this->cols() ;
   T *ptr, *aptr ;
-  ptr = m-1 ;
+  ptr = this->m-1 ;
   aptr = a.m-1 ;
   
   for (i = sze; i > 0; --i)
     *(++ptr) = *(++aptr) ;
   
-  by_columns = a.by_columns;
+  this->by_columns = a.by_columns;
   
   return *this;
 }
@@ -100,10 +100,10 @@
 {
   int rwz,coz,i,j;
   
-  if ( rows() % a.rows() != 0 || cols() % a.cols() != 0 || rows() < a.rows() || cols() < a.cols() )
+  if ( this->rows() % a.rows() != 0 || this->cols() % a.cols() != 0 || this->rows() < a.rows() || this->cols() < a.cols() )
     {
 #ifdef USE_EXCEPTION
-      throw WrongSize2D(rows(),cols(),a.rows(),a.cols()) ;
+      throw WrongSize2D(this->rows(),this->cols(),a.rows(),a.cols()) ;
 #else
       Error error("Matrix<T>::submatrix");
       error << "Matrix and submatrix incommensurate" ;
@@ -111,13 +111,13 @@
 #endif
     }
   
-  if ( sr >= rows()/a.rows() || sr < 0 || sc >= cols()/a.cols() || sc < 0 )
+  if ( sr >= this->rows()/a.rows() || sr < 0 || sc >= this->cols()/a.cols() || sc < 0 )
     {
 #ifdef USE_EXCEPTION
-      throw OutOfBound2D(sr,sc,0,rows()/a.rows()-1,0,cols()/a.cols()-1) ;
+      throw OutOfBound2D(sr,sc,0,this->rows()/a.rows()-1,0,this->cols()/a.cols()-1) ;
 #else
       Error error("Matrix<T>::submatrix");
-      error << "Submatrix location out of bounds.\nrowblock " << sr << ", " << rows()/a.rows() << " colblock " << sc << ", " << a.cols() << endl ;
+      error << "Submatrix location out of bounds.\nrowblock " << sr << ", " << this->rows()/a.rows() << " colblock " << sc << ", " << a.cols() << endl ;
       error.fatal() ;
 #endif
     }
@@ -127,7 +127,7 @@
 #ifdef COLUMN_ORDER
   for ( i = a.rows()-1; i >= 0; --i )
     for(j=a.cols()-1;j>=0;--j)
-      elem(i+rwz,j+coz) = a(i,j) ;
+      this->elem(i+rwz,j+coz) = a(i,j) ;
 #else
   T *ptr, *aptr ;
   aptr = a.m - 1;
@@ -159,7 +159,7 @@
   // Assign matrix a to this matrix at (i,j)
   int i, j;
   
-  if ( (rw + a.rows()) > rows() || ( cl + a.cols()) > cols()) {
+  if ( (rw + a.rows()) > this->rows() || ( cl + a.cols()) > this->cols()) {
 #ifdef USE_EXCEPTION
     throw MatrixErr();
 #else
@@ -172,7 +172,7 @@
 #ifdef COLUMN_ORDER
   for(i=0;i<a.rows();++i)
     for(j=0;j<a.cols();++j)
-      elem(i+rw,j+cl) = a(i,j) ;
+      this->elem(i+rw,j+cl) = a(i,j) ;
 #else
   T *pptr,*aptr ;
   aptr = a.m-1 ;
@@ -208,7 +208,7 @@
 Matrix<T> Matrix<T>::get(int rw, int cl, int nr, int nc) const
 {
   Matrix<T> getmat(nr,nc) ;
-  if ( (rw+nr) > rows() || (cl+nc) > cols()) {
+  if ( (rw+nr) > this->rows() || (cl+nc) > this->cols()) {
 #ifdef USE_EXCEPTION
     throw MatrixErr();
 #else
@@ -223,12 +223,12 @@
 #ifdef COLUMN_ORDER
   for(i=0;i<nr;++i)
     for(j=0;j<nc;++j)
-      getmat(i,j) = elem(i+rw,j+cl) ;
+      getmat(i,j) = this->elem(i+rw,j+cl) ;
 #else
   T *pptr,*aptr ;
   aptr = getmat.m-1;
   for (i = 0; i < nr; ++i) {
-    pptr = &m[(i+rw)*cols()+cl]-1 ;
+    pptr = &m[(i+rw)*this->cols()+cl]-1 ;
     for ( j = 0; j < nc; ++j)
       *(++aptr) = *(++pptr) ;
   }
@@ -252,11 +252,11 @@
   double sum, maxsum;
   int init=0 ;
   T *pptr ;
-  pptr = m-1 ;
+  pptr = this->m-1 ;
   maxsum = 0 ; // Silence the warning message
-  for(i=0;i<rows();++i){
+  for(i=0;i<this->rows();++i){
     sum = 0 ;
-    for ( j = 0; j < cols(); ++j) 
+    for ( j = 0; j < this->cols(); ++j) 
       sum += *(++pptr) ;
     if(init)
       maxsum = (maxsum>sum) ? maxsum : sum;
@@ -285,12 +285,12 @@
 {
   int i, iend;
   
-  iend = rows();
-  if ( iend > cols() )
-    iend = cols();
+  iend = this->rows();
+  if ( iend > this->cols() )
+    iend = this->cols();
   
   for (i = iend-1; i >=0; --i)
-    elem(i,i) = a;
+    this->elem(i,i) = a;
 
 }
 
@@ -308,10 +308,10 @@
 template <class T>
 Vector<T> Matrix<T>::getDiag(){
   int i, iend;
-  Vector<T> vec(minimum(rows(),cols())) ;
-  iend = minimum(rows(),cols());
+  Vector<T> vec(minimum(this->rows(),this->cols())) ;
+  iend = minimum(this->rows(),this->cols());
   for (i = iend-1; i >=0; --i)
-      vec[i] = elem(i,i);
+      vec[i] = this->elem(i,i);
   return vec ;
 }
 
@@ -328,8 +328,8 @@
 Matrix<T>& Matrix<T>::operator+=(double a)
 {
   T *p1 ;
-  p1 = m-1 ;
-  const int size = rows()*cols() ;
+  p1 = this->m-1 ;
+  const int size = this->rows()*this->cols() ;
   for(int i=size; i>0; --i)
     *(++p1) += a ;  
   return *this ;
@@ -348,8 +348,8 @@
 Matrix<T>& Matrix<T>::operator-=(double a)
 {
   T *p1 ;
-  p1 = m-1 ;
-  const int size = rows()*cols() ;
+  p1 = this->m-1 ;
+  const int size = this->rows()*this->cols() ;
   for(int i=size; i>0; --i)
     *(++p1) -= a ;  
   return *this ;
@@ -368,8 +368,8 @@
 Matrix<T>& Matrix<T>::operator*=(double a)
 {
   T *p1 ;
-  p1 = m-1 ;
-  const int size = rows()*cols() ;
+  p1 = this->m-1 ;
+  const int size = this->rows()*this->cols() ;
   for(int i=size; i>0; --i)
     *(++p1) *= a ;  
   return *this ;
@@ -388,8 +388,8 @@
 Matrix<T>& Matrix<T>::operator/=(double a)
 {
   T *p1 ;
-  p1 = m-1 ;
-  const int size = rows()*cols() ;
+  p1 = this->m-1 ;
+  const int size = this->rows()*this->cols() ;
   for(int i=size; i>0; --i)
     *(++p1) /= a ;  
   return *this ;
@@ -408,16 +408,16 @@
 template <class T> 
 Matrix<T>& Matrix<T>::operator+=(const Matrix<T> &a)
 {
-  if ( a.rows() != rows() || a.cols() != cols() )
+  if ( a.rows() != this->rows() || a.cols() != this->cols() )
     {
 #ifdef USE_EXCEPTION
-      throw WrongSize2D(rows(),cols(),a.rows(),a.cols());
+      throw WrongSize2D(this->rows(),this->cols(),a.rows(),a.cols());
 #else
       Error error("Matrix<T>::operator+=") ;
-      if ( rows() != a.rows() )
-	error << "Matrices are of diferent size, a.rows() = " << rows() << " and b.rows() = " << a.rows() << endl ;
-      if ( cols() != a.cols())
-	error << "Matrices are of diferent size, a.cols() = " << cols() << " and b.cols() = " << a.cols() << endl ;
+      if ( this->rows() != a.rows() )
+	error << "Matrices are of diferent size, a.rows() = " << this->rows() << " and b.rows() = " << a.rows() << endl ;
+      if ( this->cols() != a.cols())
+	error << "Matrices are of diferent size, a.cols() = " << this->cols() << " and b.cols() = " << a.cols() << endl ;
       error.fatal() ;
 #endif
     }
@@ -425,8 +425,8 @@
   int i, sze ;
   T *aptr,*sptr ;
   aptr = a.m - 1 ;
-  sptr = m - 1 ;
-  sze = rows()*cols() ;
+  sptr = this->m - 1 ;
+  sze = this->rows()*this->cols() ;
   for (i = sze; i > 0; --i){
       *(++sptr) += *(++aptr) ;
   }
@@ -468,16 +468,16 @@
 template <class T> 
 Matrix<T>& Matrix<T>::operator-=(const Matrix<T> &a)
 {
-  if ( a.rows() != rows() || a.cols() != cols() )
+  if ( a.rows() != this->rows() || a.cols() != this->cols() )
     {
 #ifdef USE_EXCEPTION
-      throw WrongSize2D(rows(),cols(),a.rows(),a.cols());
+      throw WrongSize2D(this->rows(),this->cols(),a.rows(),a.cols());
 #else
       Error error("Matrix<T>::operator-=") ;
-      if ( rows() != a.rows() )
-	error << "Matrices are of diferent size, a.rows() = " << rows() << " and b.rows() = " << a.rows() << endl ;
-      if ( cols() != a.cols())
-	error << "Matrices are of diferent size, a.cols() = " << cols() << " and b.cols() = " << a.cols() << endl ;
+      if ( this->rows() != a.rows() )
+	error << "Matrices are of diferent size, a.rows() = " << this->rows() << " and b.rows() = " << a.rows() << endl ;
+      if ( this->cols() != a.cols())
+	error << "Matrices are of diferent size, a.cols() = " << this->cols() << " and b.cols() = " << a.cols() << endl ;
       error.fatal() ;
 #endif
     }
@@ -485,8 +485,8 @@
   int i, size;
   T *aptr,*sptr ;
   aptr = a.m - 1 ;
-  sptr = m - 1 ;
-  size = rows()*cols() ;
+  sptr = this->m - 1 ;
+  size = this->rows()*this->cols() ;
   for (i = size; i > 0; --i){
       *(++sptr) -= *(++aptr) ;
   }
@@ -742,14 +742,14 @@
 template <class T>
 T Matrix<T>::trace() const
 {
-  int size = rows();
+  int size = this->rows();
   T sum = (T)0;
   
-  if ( size > cols() )
-    size = cols();
+  if ( size > this->cols() )
+    size = this->cols();
   
   for (int d = 0; d < size; ++d)
-    sum += elem(d,d) ;
+    sum += this->elem(d,d) ;
   
   return sum;
 }
@@ -770,12 +770,12 @@
 template <class T>
 Matrix<T> Matrix<T>::herm() const
 {
-  int i, j, r = cols(), c = rows();
+  int i, j, r = this->cols(), c = this->rows();
   Matrix<T> adj(r,c);
   
   for (i = 0; i < r; ++i)
     for (j = 0; j < c; ++j)
-      adj.elem(i,j) = elem(j,i) ;
+      adj.elem(i,j) = this->elem(j,i) ;
 
   return adj;
 
@@ -794,11 +794,11 @@
 template <class T>
 Matrix<T> Matrix<T>::flop() const
 {					
-  Matrix<T> f(rows(),cols()) ;
-  for(int i=rows()-1;i>=0;--i)
-    for(int j=cols()-1;j>=0;--j)
+  Matrix<T> f(this->rows(),this->cols()) ;
+  for(int i=this->rows()-1;i>=0;--i)
+    for(int j=this->cols()-1;j>=0;--j)
       {
-	f(i,j) = elem(i,cols()-j-1);
+	f(i,j) = elem(i,this->cols()-j-1);
       }
   return f; 
 }
@@ -817,13 +817,13 @@
 {					
   // same as hermitian for real Matrix<T>
   int i, j;
-  const int& r = cols();
-  const int& c = rows();
+  const int& r = this->cols();
+  const int& c = this->rows();
   Matrix<T> adj(r,c);
   
   for (i = r-1; i >=0; --i)
     for (j = c-1; j >=0; --j)
-      adj.elem(i,j) = elem(j,i) ;
+      adj.elem(i,j) = this->elem(j,i) ;
   
   
   return adj; 
@@ -844,7 +844,7 @@
 int Matrix<T>::read(char* filename) {
   ifstream fin(filename) ;
   if(!fin) {
-    resize(1,1) ;
+    this->resize(1,1) ;
     return 0 ;
   }
   int r,c ;
@@ -855,8 +855,8 @@
   if(r) return 0 ;
   if(!fin.read((char*)&r,sizeof(int))) return 0 ;
   if(!fin.read((char*)&c,sizeof(int))) return 0 ;
-  resize(r,c) ;
-  if(!fin.read((char*)m,sizeof(T)*r*c)) return 0 ;
+  this->resize(r,c) ;
+  if(!fin.read((char*)this->m,sizeof(T)*r*c)) return 0 ;
 
   delete []type ;
   return 1 ;
@@ -877,11 +877,11 @@
 int Matrix<T>::read(char* filename,int r, int c) {
   ifstream fin(filename) ;
   if(!fin) {
-    resize(1,1) ;
+    this->resize(1,1) ;
     return 0 ;
   }
-  resize(r,c) ;
-  if(!fin.read((char*)m,sizeof(T)*r*c)) return 0 ;
+  this->resize(r,c) ;
+  if(!fin.read((char*)this->m,sizeof(T)*r*c)) return 0 ;
 
   return 1 ;
 }
@@ -904,11 +904,11 @@
   if(!fout)
     return 0 ;
   int r,c ;
-  r = rows() ; c = cols() ;
+  r = this->rows() ; c = this->cols() ;
   if(!fout.write((char*)&"matrix",sizeof(char)*6)) return 0 ;
   if(!fout.write((char*)&r,sizeof(int))) return 0 ;
   if(!fout.write((char*)&c,sizeof(int))) return 0 ;
-  if(!fout.write((char*)m,sizeof(T)*r*c)) return 0 ;
+  if(!fout.write((char*)this->m,sizeof(T)*r*c)) return 0 ;
   return 1;
 }
 
@@ -927,7 +927,7 @@
   ofstream fout(filename) ;
   if(!fout)
     return 0 ;
-  if(!fout.write((char*)m,sizeof(T)*rows()*cols())) return 0 ;
+  if(!fout.write((char*)this->m,sizeof(T)*this->rows()*this->cols())) return 0 ;
   return 1;
 }
 
--- nurbs++-3.0.11/matrix/matrix_float.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/matrix_float.cpp	2006-04-14 22:09:21.654069500 +0200
@@ -27,6 +27,7 @@
 
 namespace PLib {
   
+  template<>
   void Matrix<float>::qSort(){
     qsort((char*)m,rows()*cols(),sizeof(float),compareFloat) ;
   }
--- nurbs++-3.0.11/matrix/vector_float.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/vector_float.cpp	2006-04-14 22:09:58.684383750 +0200
@@ -27,6 +27,7 @@
 
 namespace PLib {
 
+  template<>
   void Vector<float>::qSortStd(){
     qsort((char*)memory(),n(),sizeof(float),compareFloat) ;
   }
--- nurbs++-3.0.11/matrix/matrix_double.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/matrix_double.cpp	2006-04-14 22:14:51.230666750 +0200
@@ -27,6 +27,7 @@
 
 namespace PLib {
   
+  template<>
   void Matrix<double>::qSort(){
     qsort((char*)m,rows()*cols(),sizeof(double),compareDouble) ;
   }
--- nurbs++-3.0.11/matrix/vector_double.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/vector_double.cpp	2006-04-14 22:15:31.437179500 +0200
@@ -27,6 +27,7 @@
 
 namespace PLib {
 
+  template<>
   void Vector<double>::qSortStd(){
     qsort((char*)memory(),n(),sizeof(float),compareDouble) ;
   }
--- nurbs++-3.0.11/matrix/barray2d_uchar.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/barray2d_uchar.cpp	2006-04-14 22:19:17.831328250 +0200
@@ -27,6 +27,7 @@
 
 namespace PLib {
 
+template<>
 ostream& 
 Basic2DArray<unsigned char>::print(ostream& os) const
 {
--- nurbs++-3.0.11/matrix/matrix_char.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/matrix_char.cpp	2006-04-14 22:21:12.166473750 +0200
@@ -27,6 +27,7 @@
 
 namespace PLib {
 
+  template<>
   Matrix<char>&
     Matrix<char>::operator*=(double a)
     {
@@ -40,6 +41,7 @@
       return *this ;
     }
   
+  template<>
   Matrix<char>&
     Matrix<char>::operator+=(double a)
     {
@@ -51,6 +53,7 @@
       return *this ;
     }
   
+  template<>
   Matrix<char>&
     Matrix<char>::operator-=(double a)
     {
@@ -62,6 +65,7 @@
       return *this ;
     }
   
+  template<>
   Matrix<char>&
     Matrix<char>::operator/=(double a)
     {
--- nurbs++-3.0.11/matrix/matrix_point.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/matrix_point.cpp	2006-04-14 22:23:54.060591500 +0200
@@ -27,6 +27,7 @@
 
 namespace PLib {
 
+  template<>
   double
     Matrix<Point3Df>::norm(void) {
     int i,j ;
@@ -55,6 +56,7 @@
     return sqrt(maxsum);
   }
   
+  template<>
   double
     Matrix<Point3Dd>::norm(void) {
     int i,j ;
@@ -83,6 +85,7 @@
     return sqrt(maxsum);
   }
   
+  template<>
   double
     Matrix<Point2Df>::norm(void) {
     int i,j ;
@@ -111,6 +114,7 @@
     return sqrt(maxsum);
   }
 
+  template<>
   double
     Matrix<Point2Dd>::norm(void) {
     int i,j ;
--- nurbs++-3.0.11/matrix/matrix_hpoint.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/matrix_hpoint.cpp	2006-04-14 22:25:54.900143500 +0200
@@ -27,6 +27,7 @@
 
 namespace PLib {
 
+  template<>
   double
     Matrix<HPoint3Df>::norm(void) {
     int i,j ;
@@ -58,6 +59,7 @@
   }
   
   
+  template<>
   double
     Matrix<HPoint3Dd>::norm(void) {
     int i,j ;
@@ -89,6 +91,7 @@
   }
   
   
+  template<>
   double
     Matrix<HPoint2Df>::norm(void) {
     int i,j ;
@@ -119,6 +122,7 @@
     return sqrt(maxsum);
   }
   
+  template<>
   double
     Matrix<HPoint2Dd>::norm(void) {
     int i,j ;
--- nurbs++-3.0.11/matrix/barray_complex.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/barray_complex.cpp	2006-04-14 22:27:17.305293500 +0200
@@ -27,6 +27,7 @@
 
 namespace PLib {
 
+template<>
 ostream&
 BasicArray<Complex>::print(ostream& os)  const{
   const int iend = size();
--- nurbs++-3.0.11/matrix/matrix_complex.cpp.orig	2002-05-24 19:25:49.000000000 +0200
+++ nurbs++-3.0.11/matrix/matrix_complex.cpp	2006-04-14 22:28:02.964147000 +0200
@@ -27,6 +27,7 @@
 
 namespace PLib {
 
+  template<>
   double Matrix<Complex>::norm(void){
     int i,j ;
     double sumR, sumI, maxsum;
--- nurbs++-3.0.11/numerical/matrixMat.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/numerical/matrixMat.cpp	2006-04-14 22:37:00.125717500 +0200
@@ -48,9 +48,9 @@
 template <class T>
 LUMatrix<T>& LUMatrix<T>::operator=(const LUMatrix<T>& a){
   resize(a.rows(),a.cols()) ;
-  for(int i=0;i<rows();++i)
-    for(int j=0;j<cols();++j)
-      elem(i,j) = a(i,j) ;
+  for(int i=0;i<this->rows();++i)
+    for(int j=0;j<this->cols();++j)
+      this->elem(i,j) = a(i,j) ;
   pivot_ = a.pivot_ ;
   return *this ;
 }
@@ -90,7 +90,7 @@
   //	lu = a;	 must do it by copying or LUFACT will be recursively called !
   for(i=0;i<n;++i)
     for(j=0;j<n;++j)
-      elem(i,j) = a(i,j) ;
+      this->elem(i,j) = a(i,j) ;
 
   errval = 0;
   nm1 = n - 1;
@@ -129,24 +129,24 @@
 	    }
 	  pivot_[k] = l;
 
-	  if ( elem(l,k) != 0.0 )
+	  if ( this->elem(l,k) != 0.0 )
 	    {			// nonsingular pivot found 
 	      if (l != k ){	// interchange needed 
 		for (i = k; i < n; i++)
 		  {
-		    t = elem(l,i) ;
-		    elem(l,i) = elem(k,i) ;
-		    elem(k,i) = t ; 
+		    t = this->elem(l,i) ;
+		    this->elem(l,i) = this->elem(k,i) ;
+		    this->elem(k,i) = t ; 
 		  }
 		sign = -sign ;
 	      }
-	      q =  elem(k,k);	/* scale row */
+	      q =  this->elem(k,k);	/* scale row */
 	      for (i = kp1; i < n; i++)
 		{
-		  t = - elem(i,k)/q;
-		  elem(i,k) = t;
+		  t = - this->elem(i,k)/q;
+		  this->elem(i,k) = t;
 		  for (j = kp1; j < n; j++)
-		    elem(i,j) += t * elem(k,j);
+		    this->elem(i,j) += t * this->elem(k,j);
 		}
 	    }
 	  else		/* pivot singular */
@@ -156,7 +156,7 @@
     }
   
   pivot_[nm1] = nm1;
-  if (elem(nm1,nm1) == 0.0)
+  if (this->elem(nm1,nm1) == 0.0)
     errval = nm1;  
   return *this;
 }
@@ -196,9 +196,9 @@
 */
 template <class T>
 T LUMatrix<T>::determinant(){
-  T det = elem(0,0) ;
-  for(int i=1;i<rows();++i)
-    det *= elem(i,i) ;
+  T det = this->elem(0,0) ;
+  for(int i=1;i<this->rows();++i)
+    det *= this->elem(i,i) ;
   return det * (T)sign ;
 }
 
@@ -253,18 +253,18 @@
   T ten;
   int i, j, k, l, kb, kp1, nm1, n, coln;
 
-  if ( rows() != cols() )
+  if ( this->rows() != this->cols() )
     {
 #ifdef USE_EXCEPTION
-    throw WrongSize2D(rows(),cols(),0,0) ;
+    throw WrongSize2D(this->rows(),this->cols(),0,0) ;
 #else
       Error error("invm");
-      error << "matrix inverse, not square: " << rows() << " by " << cols() << endl;
+      error << "matrix inverse, not square: " << this->rows() << " by " << this->cols() << endl;
       error.fatal();
 #endif
     }
 
-  n = coln = rows();
+  n = coln = this->rows();
 
 
   inv = *this ;
@@ -338,13 +338,13 @@
 template <class T>
 Matrix<T> LUMatrix<T>::inverse() 
 {
-  if ( rows() != cols() )
+  if ( this->rows() != this->cols() )
     {
 #ifdef USE_EXCEPTION
-      throw WrongSize2D(rows(),cols(),0,0) ;
+      throw WrongSize2D(this->rows(),this->cols(),0,0) ;
 #else
       Error error("invm");
-      error << "matrix inverse, not square: " << rows() << " by " << cols() << endl;
+      error << "matrix inverse, not square: " << this->rows() << " by " << this->cols() << endl;
       error.fatal();
 #endif
     }
--- nurbs++-3.0.11/image/color.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/image/color.cpp	2006-04-14 22:45:45.654561000 +0200
@@ -50,6 +50,7 @@
   Color blackColor(0,0,0) ;
   */
 
+  template<>
   double
     Matrix<Color>::norm(void) {
 #ifdef USE_EXCEPTION
@@ -63,6 +64,7 @@
   }
 
 #ifndef USING_VCC
+  template<>
   int Matrix<Color>::read(char* filename,int r, int c) {
     ifstream fin(filename) ;
     if(!fin) {
@@ -89,6 +91,7 @@
   }
 #endif
 
+  template<>
   int Vector<Color>::minIndex() const {
 #ifdef USE_EXCEPTION
     throw MatrixErr() ;
--- nurbs++-3.0.11/image/image.cpp.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/image/image.cpp	2006-04-14 22:48:32.116964250 +0200
@@ -55,9 +55,9 @@
 void MatrixImage<T>::drawLine(int i1, int j1, int i2, int j2, T color){
   int i,j ;
   double mx,b ;
-  if(i1<0 || j1<0 || i1>rows() || j1>=cols()  ){
+  if(i1<0 || j1<0 || i1>this->rows() || j1>=this->cols()  ){
 #ifdef USE_EXCEPTION
-    throw OutOfBound2D(i1,j1,0,rows()-1,0,cols()-1) ;
+    throw OutOfBound2D(i1,j1,0,this->rows()-1,0,this->cols()-1) ;
 #else
     Error error("MatrixImage<T>::drawLine") ;
     error << "Error in drawing line\n Invalid index ("<< i1 << ", " << j1 << ") to ( " << i2 << ", " << j2 << ") \n" ;
@@ -65,9 +65,9 @@
 #endif
     return ;
   }
-  if(i2 <0 || j2<0 || i2>rows() || j2>=cols() ){
+  if(i2 <0 || j2<0 || i2>this->rows() || j2>=this->cols() ){
 #ifdef USE_EXCEPTION
-    throw OutOfBound2D(i2,j2,0,rows()-1,0,cols()-1) ;
+    throw OutOfBound2D(i2,j2,0,this->rows()-1,0,this->cols()-1) ;
 #else
     Error error("MatrixImage<T>::drawLine") ;
     error << "Error in drawing line\n Invalid index ("<< i1 << ", " << j1 << ") to ( " << i2 << ", " << j2 << ") \n" ;
@@ -79,7 +79,7 @@
   // check if line is vertical
   if(j1==j2){
     for(i=minimum(i1,i2);i<=maximum(i1,i2);i++)
-     operator()(i,j1) = color ;
+     this->operator()(i,j1) = color ;
     return ;
   }
   mx = (double)(i1-i2)/(double)(j1-j2) ;
@@ -88,13 +88,13 @@
     if(i1>i2){
       for(i=i1;i>=i2;i--){
 	j = int(((double)i-b)/mx) ;
-	operator()(i,j) = color ;
+	this->operator()(i,j) = color ;
       }
     }
     else{
       for(i=i1;i<=i2;i++){
 	j = (int)((i-b)/mx) ;
-	operator()(i,j) = color ;
+	this->operator()(i,j) = color ;
       }
     }
   }
@@ -102,13 +102,13 @@
     if(j1>j2){
       for(j=j1;j>=j2;j--){
 	i = (int)(mx*j+b) ;
-	operator()(i,j) = color ;
+	this->operator()(i,j) = color ;
       }
     }
     else{
       for(j=j1;j<=j2;j++){
 	i = (int)(mx*j+b) ;
-	operator()(i,j) = color ;
+	this->operator()(i,j) = color ;
       }
     }
   }
@@ -133,9 +133,9 @@
 void MatrixImage<T>::drawPoint(int i, int j, double r , T color){
   for(int y=i-int(ceil(r)) ; y<i+int(ceil(r)) ; y++)
     for(int x = j-int(ceil(r)) ; x<j+int(ceil(r)) ; x++){
-      if(y>=0 && y<rows() && x>=0 && x<cols()){
+      if(y>=0 && y<this->rows() && x>=0 && x<this->cols()){
 	if( ((y-i)*(y-i)+(x-j)*(x-j))<= r*r)
-	  operator()(y,x) = color ;
+	  this->operator()(y,x) = color ;
       }
     }
 }
@@ -153,14 +153,14 @@
 */
 template <class T>
 void MatrixImage<T>::store(Matrix<T>& a){
-  if(a.rows() != rows() || a.cols() != cols()) {
-    a.resize(rows(),cols()) ;
+  if(a.rows() != this->rows() || a.cols() != this->cols()) {
+    a.resize(this->rows(),this->cols()) ;
   }
   T *aptr, *bptr ;
   int size,i ;
   aptr = &a(0,0)-1 ;
-  bptr = m-1 ;
-  size = cols()*rows() ;
+  bptr = this->m-1 ;
+  size = this->cols()*this->rows() ;
   for(i=0;i<size;i++)
     *(++aptr) = *(++bptr) ;  
 }
--- nurbs++-3.0.11/image/image_.cpp.orig	2006-04-14 20:38:02.847665000 +0200
+++ nurbs++-3.0.11/image/image_.cpp	2006-04-14 22:49:10.771380000 +0200
@@ -29,6 +29,7 @@
 
 #if defined(WITH_IMAGE_MAGICK)
 
+  template<>
   void IM_ImageT<Color>::setMatrix(){
     PixelPacket *pixels=GetImagePixels(image,0,0,cols(),rows());
 #ifdef COLUMN_ORDER
@@ -48,6 +49,7 @@
 #endif
   }
   
+  template<>
   void IM_ImageT<unsigned char>::setMatrix(){
     PixelPacket *pixels=GetImagePixels(image,0,0,cols(),rows());
 #ifdef COLUMN_ORDER
@@ -63,6 +65,7 @@
   }
 
  
+  template<>
   void IM_ImageT<Color>::setImage(){
     if(image->rows != (unsigned int)rows() || image->columns != (unsigned int)cols()){
       char *pixmem=(char*)malloc(cols()*rows()*3);
@@ -92,6 +95,7 @@
     SyncImagePixels(image);
   }
   
+  template<>
   void IM_ImageT<unsigned char>::setImage(){
     if(image->rows != (unsigned int)rows() || image->columns != (unsigned int)cols()){
       char *pixmem=(char*)malloc(cols()*rows()*3);
@@ -123,6 +127,7 @@
   
   
   
+  template<>
   int IM_ImageT<Color>::read(const char* filename) {
     ExceptionInfo exc;
     (void)strcpy(image_info.filename,filename) ;
@@ -139,6 +144,7 @@
     return 1 ;
   }
   
+  template<>
   int IM_ImageT<unsigned char>::read(const char* filename) {
     ExceptionInfo exc;
     (void)strcpy(image_info.filename,filename) ;
@@ -156,6 +162,7 @@
     return 1 ;
   }
   
+  template<>
   int IM_ImageT<Color>::write(const char* filename) {
     
     if(image)
@@ -176,6 +183,7 @@
     return WriteImage(&image_info,image) ;
   }
   
+  template<>
   int IM_ImageT<unsigned char>::write(const char* filename) {
     if(image)
       DestroyImage(image) ;
--- nurbs++-3.0.11/matrix/list.h.orig	2002-05-13 23:07:45.000000000 +0200
+++ nurbs++-3.0.11/matrix/list.h	2006-04-15 15:53:28.048219750 +0200
@@ -56,7 +56,7 @@
 {
 public:
   BasicList() ;
-  BasicList(BasicList<T>& a) ;
+  BasicList(BasicList<T> const & a) ;
   ~BasicList() { reset() ; }
 
 
@@ -125,7 +125,7 @@
   Modified by:
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 template <class T>
-BasicList<T>::BasicList(BasicList<T>& a): BasicNode<T>() {
+BasicList<T>::BasicList(BasicList<T> const & a): BasicNode<T>() {
   first_ = last_ = 0 ;
   current = first_ ;
   *this = a ; 
--- nurbs++-3.0.11/nurbs/d_nurbs.cpp.orig	2002-05-13 22:11:57.000000000 +0200
+++ nurbs++-3.0.11/nurbs/d_nurbs.cpp	2006-04-15 16:12:48.096718250 +0200
@@ -10,6 +10,7 @@
   return firstDn(u) ;
 }
 
+template <>
 void NurbsCurve<double,2>::makeCircle(const Point_nD<double,2>& O, double r, double as, double ae){
   makeCircle(O,Point_nD<double,2>(1,0),Point_nD<double,2>(0,1),r,as,ae) ;
 }
--- nurbs++-3.0.11/nurbs/nurbsSub.cpp.orig	2002-05-13 23:07:46.000000000 +0200
+++ nurbs++-3.0.11/nurbs/nurbsSub.cpp	2006-04-15 15:19:32.909031500 +0200
@@ -904,7 +904,7 @@
   
   /* Allocate storage for the grid of points generated */
   
-  CHECK( pts = new (SurfSample<T>*)[Granularity+1]);
+  CHECK( pts = new SurfSample<T>*[Granularity+1]);
   CHECK( pts[0] = new SurfSample<T>[(Granularity+1)*(Granularity+1)]);
   
   for (i = 1; i <= Granularity; i++)
@@ -983,7 +983,7 @@
   
   if (! *alpha)	/* Must allocate alpha */
     {
-      CHECK( *alpha = new (T*)[k+1]);
+      CHECK( *alpha = new T*[k+1]);
       for (i = 0; i <= k; i++)
 	CHECK( (*alpha)[i] = new T[(m + n + 1)]);
     }
--- nurbs++-3.0.11/nurbs/nurbs.cpp.orig	2002-05-24 19:25:49.000000000 +0200
+++ nurbs++-3.0.11/nurbs/nurbs.cpp	2006-04-15 12:09:10.999206750 +0200
@@ -391,9 +391,9 @@
   T du,dv ;
   // compute a coarse distance for the curve
   Point_nD<T,N> a,b,c ;
-  a = pointAt(0.0) ;
-  b = pointAt(0.5) ;
-  c = pointAt(1.0) ;
+  a = this->pointAt(0.0) ;
+  b = this->pointAt(0.5) ;
+  c = this->pointAt(1.0) ;
 
   T distance = norm(b-a) + norm(c-b) ;
 
--- nurbs++-3.0.11/nurbs/matrixRT.cpp.orig	2002-05-13 23:07:46.000000000 +0200
+++ nurbs++-3.0.11/nurbs/matrixRT.cpp	2006-04-15 13:37:39.562971250 +0200
@@ -51,13 +51,13 @@
   // *this = C.translate(x,y,z)*B.rotate(ax,ay,az) ;
   rotate(ax,ay,az) ;
 #ifdef COLUMN_ORDER
-  m[12] = x ;
-  m[13] = y ;
-  m[14] = z ;  
+  this->m[12] = x ;
+  this->m[13] = y ;
+  this->m[14] = z ;  
 #else
-  m[3] = x ;
-  m[7] = y ;
-  m[11] = z ;
+  this->m[3] = x ;
+  this->m[7] = y ;
+  this->m[11] = z ;
 #endif
 }
 
@@ -71,8 +71,8 @@
  */
 template <class T>
 MatrixRT<T>::MatrixRT() : Matrix<T>(4,4) {
-  reset(0) ;
-  diag(1.0) ;
+  this->reset(0) ;
+  this->diag(1.0) ;
 }
 
 /*!
@@ -144,33 +144,33 @@
   t10 = cos(ax);
   t13 = t4*t6;
 #ifdef COLUMN_ORDER
-  m[0] = t1*t2;
-  m[4] = -t4*t2;
-  m[8] = t6;
-  m[12] = 0 ;
-  m[1] = t7*t8+t4*t10;
-  m[5] = -t13*t8+t1*t10;
-  m[9] = -t2*t8;
-  m[13] = 0 ;
-  m[2] = -t7*t10+t4*t8;
-  m[6] = t13*t10+t1*t8;
-  m[10] = t2*t10;
-  m[14] = m[3] = m[7] = m[11] = 0.0 ;
-  m[15] = 1.0 ;
+  this->m[0] = t1*t2;
+  this->m[4] = -t4*t2;
+  this->m[8] = t6;
+  this->m[12] = 0 ;
+  this->m[1] = t7*t8+t4*t10;
+  this->m[5] = -t13*t8+t1*t10;
+  this->m[9] = -t2*t8;
+  this->m[13] = 0 ;
+  this->m[2] = -t7*t10+t4*t8;
+  this->m[6] = t13*t10+t1*t8;
+  this->m[10] = t2*t10;
+  this->m[14] = this->m[3] = this->m[7] = this->m[11] = 0.0 ;
+  this->m[15] = 1.0 ;
 #else
-  m[0] = t1*t2;
-  m[1] = -t4*t2;
-  m[2] = t6;
-  m[3] = 0 ;
-  m[4] = t7*t8+t4*t10;
-  m[5] = -t13*t8+t1*t10;
-  m[6] = -t2*t8;
-  m[7] = 0 ;
-  m[8] = -t7*t10+t4*t8;
-  m[9] = t13*t10+t1*t8;
-  m[10] = t2*t10;
-  m[11] = m[12] = m[13] = m[14] = 0 ;
-  m[15] = 1.0 ;
+  this->m[0] = t1*t2;
+  this->m[1] = -t4*t2;
+  this->m[2] = t6;
+  this->m[3] = 0 ;
+  this->m[4] = t7*t8+t4*t10;
+  this->m[5] = -t13*t8+t1*t10;
+  this->m[6] = -t2*t8;
+  this->m[7] = 0 ;
+  this->m[8] = -t7*t10+t4*t8;
+  this->m[9] = t13*t10+t1*t8;
+  this->m[10] = t2*t10;
+  this->m[11] = this->m[12] = this->m[13] = this->m[14] = 0 ;
+  this->m[15] = 1.0 ;
 #endif
   return *this ;
 }
@@ -203,33 +203,33 @@
   t9 = (T)sin((double)ax);
   t17 = t4*t7;
 #ifdef COLUMN_ORDER
-  m[0] = t1*t2;
-  m[4] = -t4*t5+t8*t9;
-  m[8] = t4*t9+t8*t5;
-  m[12] = 0.0 ;
-  m[1] = t4*t2;
-  m[5] = t1*t5+t17*t9;
-  m[9] = -t1*t9+t17*t5;
-  m[13] = 0.0 ;
-  m[2] = -t7;
-  m[6] = t2*t9;
-  m[10] = t2*t5;
-  m[14] = m[3] = m[7] = m[11] = 0 ;
-  m[15] = 1.0 ;
+  this->m[0] = t1*t2;
+  this->m[4] = -t4*t5+t8*t9;
+  this->m[8] = t4*t9+t8*t5;
+  this->m[12] = 0.0 ;
+  this->m[1] = t4*t2;
+  this->m[5] = t1*t5+t17*t9;
+  this->m[9] = -t1*t9+t17*t5;
+  this->m[13] = 0.0 ;
+  this->m[2] = -t7;
+  this->m[6] = t2*t9;
+  this->m[10] = t2*t5;
+  this->m[14] = this->m[3] = this->m[7] = this->m[11] = 0 ;
+  this->m[15] = 1.0 ;
 #else
-  m[0] = t1*t2;
-  m[1] = -t4*t5+t8*t9;
-  m[2] = t4*t9+t8*t5;
-  m[3] = 0.0 ;
-  m[4] = t4*t2;
-  m[5] = t1*t5+t17*t9;
-  m[6] = -t1*t9+t17*t5;
-  m[7] = 0.0 ;
-  m[8] = -t7;
-  m[9] = t2*t9;
-  m[10] = t2*t5;
-  m[11] = m[12] = m[13] = m[14] = 0 ;
-  m[15] = 1.0 ;
+  this->m[0] = t1*t2;
+  this->m[1] = -t4*t5+t8*t9;
+  this->m[2] = t4*t9+t8*t5;
+  this->m[3] = 0.0 ;
+  this->m[4] = t4*t2;
+  this->m[5] = t1*t5+t17*t9;
+  this->m[6] = -t1*t9+t17*t5;
+  this->m[7] = 0.0 ;
+  this->m[8] = -t7;
+  this->m[9] = t2*t9;
+  this->m[10] = t2*t5;
+  this->m[11] = this->m[12] = this->m[13] = this->m[14] = 0 ;
+  this->m[15] = 1.0 ;
 #endif
   return *this ;
 }
@@ -245,16 +245,16 @@
  */
 template <class T>
 MatrixRT<T>& MatrixRT<T>::translate(T x, T y, T z){
-  reset(0) ;
-  diag(1.0) ;
+  this->reset(0) ;
+  this->diag(1.0) ;
 #ifdef COLUMN_ORDER
-  m[12] = x ;
-  m[13] = y ;
-  m[14] = z ;
+  this->m[12] = x ;
+  this->m[13] = y ;
+  this->m[14] = z ;
 #else
-  m[3] = x ;
-  m[7] = y ;
-  m[11] = z ;
+  this->m[3] = x ;
+  this->m[7] = y ;
+  this->m[11] = z ;
 #endif
   return *this ;
 }
@@ -271,11 +271,11 @@
  */
 template <class T>
 MatrixRT<T>& MatrixRT<T>::scale(T x, T y, T z){
-  reset(0) ;
-  m[0] = x ;
-  m[5] = y ;
-  m[10] = z ;
-  m[15] = 1.0 ;
+  this->reset(0) ;
+  this->m[0] = x ;
+  this->m[5] = y ;
+  this->m[10] = z ;
+  this->m[15] = 1.0 ;
   return *this ;
 }
 
@@ -416,7 +416,7 @@
     error.fatal() ;
   }
   T *a,*b ;
-  a = m-1 ;
+  a = this->m-1 ;
   b = M[0] - 1 ;
   for(int i=0;i<16;++i){
     *(++a) = *(++b) ;
@@ -435,7 +435,7 @@
 template <class T>
 MatrixRT<T>& MatrixRT<T>::operator=(const MatrixRT<T>& M) {
   T *a,*b ;
-  a = m-1 ;
+  a = this->m-1 ;
   b = M.m - 1 ;
   for(int i=0;i<16;++i){
     *(++a) = *(++b) ;
--- nurbs++-3.0.11/nurbs/nurbs_sp.h.orig	2002-05-17 20:24:21.000000000 +0200
+++ nurbs++-3.0.11/nurbs/nurbs_sp.h	2006-04-15 13:47:15.090939500 +0200
@@ -72,7 +72,7 @@
   int read(ifstream &fin) ;
 
   void modSurfCPby(int i, const HPoint_nD<T,N>& a) 
-    { P[i] +=  a / maxU[i] ;  }
+    { this->P[i] +=  a / maxU[i] ;  }
   void modSurfCP(int i, const HPoint_nD<T,N>& a) 
     { modSurfCPby(i,a-surfP(i)) ;  }
 
--- nurbs++-3.0.11/nurbs/nurbs_sp.cpp.orig	2002-05-13 23:07:46.000000000 +0200
+++ nurbs++-3.0.11/nurbs/nurbs_sp.cpp	2006-04-15 14:03:47.804980250 +0200
@@ -41,7 +41,7 @@
 */
 template <class T, int N>
 void NurbsCurveSP<T,N>::updateMaxU() {
-  if(deg_>3){
+  if(this->deg_>3){
 #ifdef USE_EXCEPTION
     throw NurbsInputError();
 #else
@@ -51,10 +51,10 @@
 #endif
   }
   else{
-    maxU.resize(P.n()) ;
-    maxAt_.resize(P.n()) ;
-    for(int i=0;i<P.n();++i){
-      if(!maxInfluence(i,U,deg_,maxAt_[i]))
+    maxU.resize(this->P.n()) ;
+    maxAt_.resize(this->P.n()) ;
+    for(int i=0;i<this->P.n();++i){
+      if(!maxInfluence(i,this->U,this->deg_,maxAt_[i]))
 	cerr << "Problem in maxInfluence U!\n" ;
       if(i>0)
 	if(maxAt_[i]<maxAt_[i-1]){
@@ -69,7 +69,7 @@
 	  error.fatal() ; 
 #endif
 	}
-      maxU[i] = basisFun(maxAt_[i],i,deg_) ;
+      maxU[i] = basisFun(maxAt_[i],i,this->deg_) ;
     }
     
   }
@@ -96,14 +96,14 @@
 */
 template <class T, int N>
 void NurbsCurveSP<T,N>::modOnlySurfCPby(int i, const HPoint_nD<T,N>& a){
-  Vector<T> u(2*deg_+3) ;
-  Vector< Point_nD<T,N> > pts(2*deg_+3) ; 
+  Vector<T> u(2*this->deg_+3) ;
+  Vector< Point_nD<T,N> > pts(2*this->deg_+3) ; 
 
   int n=0;
-  for(int j=i-deg_-1;j<=i+deg_+1;++j){
+  for(int j=i-this->deg_-1;j<=i+this->deg_+1;++j){
     if(j<0)
       continue ;
-    if(j>=P.n())
+    if(j>=this->P.n())
       break ; 
     u[n] = maxAt_[j] ;
     if( j == i){
--- nurbs++-3.0.11/nurbs/nurbsS_sp.h.orig	2002-05-13 23:07:46.000000000 +0200
+++ nurbs++-3.0.11/nurbs/nurbsS_sp.h	2006-04-15 14:04:33.155814500 +0200
@@ -78,7 +78,7 @@
 
 
   void modSurfCPby(int i, int j, const HPoint_nD<T,N>& a) //!< Moves a surface point by a value
-    { P(i,j) +=  a / (maxU[i]*maxV[j]) ;  }
+    { this->P(i,j) +=  a / (maxU[i]*maxV[j]) ;  }
   void modSurfCP(int i, int j, const HPoint_nD<T,N>& a) //!< Moves a surface point to a value
     { modSurfCPby(i,j,a-surfP(i,j)) ;  }
 
--- nurbs++-3.0.11/nurbs/nurbsGL.cpp.orig	2006-04-14 22:50:54.949890000 +0200
+++ nurbs++-3.0.11/nurbs/nurbsGL.cpp	2006-04-15 18:54:29.787036000 +0200
@@ -3912,20 +3912,8 @@
 
 #ifdef NO_IMPLICIT_TEMPLATES
 
-template class std::list<NurbsCurve_2Df*> ;
-template class std::list<NurbsCurve_2Df*>::iterator ;
-
 template class RenderMeshGL<float> ;
 
-template class std::allocator<PLib::NurbsCurve<float, 2> *>;
-
-template void  std::_List_base<PLib::NurbsCurve<float, 2> *, std::allocator<PLib::NurbsCurve<float, 2> *> >::clear(void);
-
-template void std::list<NurbsCurve_2Df*>::clear(void);
-
-template void std::list<PLib::NurbsCurve<float, 2> *, std::allocator<PLib::NurbsCurve<float, 2> *> >::_M_insert_dispatch<std::_List_iterator<PLib::NurbsCurve<float, 2> *, PLib::NurbsCurve<float, 2> *const &, PLib::NurbsCurve<float, 2> *const *> >(std::_List_iterator<PLib::NurbsCurve<float, 2> *, PLib::NurbsCurve<float, 2> *&, PLib::NurbsCurve<float, 2> **>, std::_List_iterator<PLib::NurbsCurve<float, 2> *, PLib::NurbsCurve<float,
-2> *const &, PLib::NurbsCurve<float, 2> *const *>, std::_List_iterator<PLib::NurbsCurve<float, 2> *, PLib::NurbsCurve<float, 2> *const &, PLib::NurbsCurve<float, 2> *const *>, __false_type);
-
 /*
 template void list<PLib::NurbsCurve<float, 2> *, __default_alloc_template<0, 0> >::insert<__list_iterator<PLib::NurbsCurve<float, 2> *, PLib::NurbsCurve<float, 2> *const &, PLib::NurbsCurve<float, 2> *const *> >(__list_iterator<PLib::NurbsCurve<float, 2> *, PLib::NurbsCurve<float, 2> *&, PLib::NurbsCurve<float, 2> **>, __list_iterator<PLib::NurbsCurve<float, 2> *, PLib::NurbsCurve<float, 2> *const &, PLib::NurbsCurve<float, 2> *const *>, __list_iterator<PLib::NurbsCurve<float, 2> *, PLib::NurbsCurve<float, 2> *const &, PLib::NurbsCurve<float, 2> *const *>) ;
 template void list<PLib::NurbsCurve<float, 2> *, __default_alloc_template<1, 0> >::insert<__list_iterator<PLib::NurbsCurve<float, 2> *, PLib::NurbsCurve<float, 2> *const &, PLib::NurbsCurve<float, 2> *const *> >(__list_iterator<PLib::NurbsCurve<float, 2> *, PLib::NurbsCurve<float, 2> *&, PLib::NurbsCurve<float, 2> **>, __list_iterator<PLib::NurbsCurve<float, 2> *, PLib::NurbsCurve<float, 2> *const &, PLib::NurbsCurve<float, 2> *const *>, __list_iterator<PLib::NurbsCurve<float, 2> *, PLib::NurbsCurve<float, 2> *const &, PLib::NurbsCurve<float, 2> *const *>) ;
@@ -3955,6 +3943,18 @@
 
 } // end namespace
 
+#ifdef NO_IMPLICIT_TEMPLATES
+
+template class std::list<PLib::NurbsCurve_2Df*> ;
+
+template void std::_List_base<PLib::NurbsCurve<float, 2> *, std::allocator<PLib::NurbsCurve<float, 2> *> >::_M_clear(void);
+
+template void __gnu_cxx::__mt_alloc<std::_List_node<PLib::NurbsCurve<float, 2>*>, __gnu_cxx::__common_pool_policy<__gnu_cxx::__pool, true> >::deallocate(std::_List_node<PLib::NurbsCurve<float, 2>*>*, unsigned int);
+
+template std::_List_node<PLib::NurbsCurve<float, 2>*>* __gnu_cxx::__mt_alloc<std::_List_node<PLib::NurbsCurve<float, 2>*>, __gnu_cxx::__common_pool_policy<__gnu_cxx::__pool, true> >::allocate(unsigned int, void const*);
+
+#endif
+
 #endif
 
 
--- nurbs++-3.0.11/nurbs/f_nurbsSub.cpp.orig	2002-05-13 22:11:57.000000000 +0200
+++ nurbs++-3.0.11/nurbs/f_nurbsSub.cpp	2006-04-15 15:47:47.578941750 +0200
@@ -14,7 +14,9 @@
   template class RenderMeshPoints<float> ;
 
   
+  template<>
   float NurbSurface<float>::epsilon = 1e-6 ;
+  template<>
   float SurfSample<float>::epsilon = 1e-6 ;
 
   template void DrawSubdivision( NurbSurface<float> *, float tolerance );
--- nurbs++-3.0.11/nurbs/nurbsS.cpp.orig	2002-05-13 23:07:46.000000000 +0200
+++ nurbs++-3.0.11/nurbs/nurbsS.cpp	2006-04-15 12:16:34.858946250 +0200
@@ -3762,12 +3762,12 @@
   // we use and angle of 36 to view the object
   // and position the rest according to this.
   Point_nD<T,N> minP, maxP ;
-  minP.x() = extremum(1,coordX) ;
-  minP.y() = extremum(1,coordY) ;
-  minP.z() = extremum(1,coordZ) ;
-  maxP.x() = extremum(0,coordX) ;
-  maxP.y() = extremum(0,coordY) ;
-  maxP.z() = extremum(0,coordZ) ;
+  minP.x() = this->extremum(1,coordX) ;
+  minP.y() = this->extremum(1,coordY) ;
+  minP.z() = this->extremum(1,coordZ) ;
+  maxP.x() = this->extremum(0,coordX) ;
+  maxP.y() = this->extremum(0,coordY) ;
+  maxP.z() = this->extremum(0,coordZ) ;
 
   Point_nD<T,N> lookAt  ;
   lookAt.x() = (minP.x()+maxP.x())/2.0 ;
@@ -3860,12 +3860,12 @@
   // we use and angle of 36 to view the object
   // and position the rest according to this.
   Point_nD<T,N> minP, maxP ;
-  minP.x() = extremum(1,coordX) ;
-  minP.y() = extremum(1,coordY) ;
-  minP.z() = extremum(1,coordZ) ;
-  maxP.x() = extremum(0,coordX) ;
-  maxP.y() = extremum(0,coordY) ;
-  maxP.z() = extremum(0,coordZ) ;
+  minP.x() = this->extremum(1,coordX) ;
+  minP.y() = this->extremum(1,coordY) ;
+  minP.z() = this->extremum(1,coordZ) ;
+  maxP.x() = this->extremum(0,coordX) ;
+  maxP.y() = this->extremum(0,coordY) ;
+  maxP.z() = this->extremum(0,coordZ) ;
 
   Point_nD<T,N> lookAt  ;
   lookAt.x() = (minP.x()+maxP.x())/2.0 ;
@@ -4045,12 +4045,12 @@
   }
 
   Point_nD<T,N> minP, maxP ;
-  minP.x() = extremum(1,coordX) ;
-  minP.y() = extremum(1,coordY) ;
-  minP.z() = extremum(1,coordZ) ;
-  maxP.x() = extremum(0,coordX) ;
-  maxP.y() = extremum(0,coordY) ;
-  maxP.z() = extremum(0,coordZ) ;
+  minP.x() = this->extremum(1,coordX) ;
+  minP.y() = this->extremum(1,coordY) ;
+  minP.z() = this->extremum(1,coordZ) ;
+  maxP.x() = this->extremum(0,coordX) ;
+  maxP.y() = this->extremum(0,coordY) ;
+  maxP.z() = this->extremum(0,coordZ) ;
 
   Point_nD<T,N> lookAt  ;
   lookAt.x() = (minP.x()+maxP.x())/2.0 ;
--- nurbs++-3.0.11/nurbs/nurbsS_sp.cpp.orig	2002-05-13 23:07:46.000000000 +0200
+++ nurbs++-3.0.11/nurbs/nurbsS_sp.cpp	2006-04-15 14:17:17.087557250 +0200
@@ -43,7 +43,7 @@
 */
 template <class T, int N>
 void NurbsSurfaceSP<T,N>::updateMaxU() {
-  if(degU>3){
+  if(this->degU>3){
 #ifdef USE_EXCEPTION
     throw NurbsInputError();
 #else
@@ -53,12 +53,12 @@
 #endif
   }
   else{
-    maxU.resize(P.rows()) ;
-    maxAtU_.resize(P.rows()) ;
-    for(int i=0;i<P.rows();++i){
-      if(!maxInfluence(i,U,degU,maxAtU_[i]))
+    maxU.resize(this->P.rows()) ;
+    maxAtU_.resize(this->P.rows()) ;
+    for(int i=0;i<this->P.rows();++i){
+      if(!maxInfluence(i,this->U,this->degU,maxAtU_[i]))
 	cerr << "Problem in maxInfluence U!\n" ;
-      maxU[i] = nurbsBasisFun(maxAtU_[i],i,degU,U) ;
+      maxU[i] = nurbsBasisFun(maxAtU_[i],i,this->degU,this->U) ;
     }
     
   }
@@ -78,7 +78,7 @@
 */
 template <class T, int N>
 void NurbsSurfaceSP<T,N>::updateMaxV() {
-  if(degV>3){
+  if(this->degV>3){
 #ifdef USE_EXCEPTION
     throw NurbsInputError();
 #else
@@ -88,12 +88,12 @@
 #endif
   }
   else{
-    maxV.resize(P.cols()) ;
-    maxAtV_.resize(P.cols()) ;
-    for(int i=0;i<P.cols();++i){
-      if(!maxInfluence(i,V,degV,maxAtV_[i]))
+    maxV.resize(this->P.cols()) ;
+    maxAtV_.resize(this->P.cols()) ;
+    for(int i=0;i<this->P.cols();++i){
+      if(!maxInfluence(i,this->V,this->degV,maxAtV_[i]))
 	cerr << "Problem in maxInfluence V!\n" ;
-      maxV[i] = nurbsBasisFun(maxAtV_[i],i,degV,V) ;
+      maxV[i] = nurbsBasisFun(maxAtV_[i],i,this->degV,this->V) ;
     }
     
   }
@@ -124,11 +124,11 @@
 NurbsSurfaceSP<T,N> NurbsSurfaceSP<T,N>::generateParallel(T d) const {
   NurbsSurfaceSP<T,N> p(*this) ;
 
-  Vector< Point_nD<T,N> > offset(P.rows()*P.cols()) ;
-  Vector<T> ur(P.rows()*P.cols()) ;
-  Vector<T> vr(P.rows()*P.cols()) ;
-  Vector_INT Du(P.rows()*P.cols()) ;
-  Vector_INT Dv(P.rows()*P.cols()) ;
+  Vector< Point_nD<T,N> > offset(this->P.rows()*this->P.cols()) ;
+  Vector<T> ur(this->P.rows()*this->P.cols()) ;
+  Vector<T> vr(this->P.rows()*this->P.cols()) ;
+  Vector_INT Du(this->P.rows()*this->P.cols()) ;
+  Vector_INT Dv(this->P.rows()*this->P.cols()) ;
 
   Du.reset(0) ;
   Dv.reset(0) ;
@@ -137,8 +137,8 @@
 
   no = 0 ;
 
-  for(i=0;i<P.rows();++i)
-    for(j=0;j<P.cols();++j){
+  for(i=0;i<this->P.rows();++i)
+    for(j=0;j<this->P.cols();++j){
       Point_nD<T,N> norm ;
       norm = normal(maxAtU_[i],maxAtV_[j]) ;
       if(norm.x() == T(0) && 
@@ -155,19 +155,19 @@
 	  norm /= T(2) ;
 	  ok = 1 ;
 	}
-	if(i==P.rows()-1 && j==P.cols()-1){
+	if(i==this->P.rows()-1 && j==this->P.cols()-1){
 	  norm = normal(maxAtU_[i]-delta,maxAtV_[j]) ;
 	  norm += normal(maxAtU_[i],maxAtV_[j]-delta) ;
 	  norm /= T(2) ;
 	  ok = 1 ;
 	}
-	if(i==0 && j==P.cols()-1){
+	if(i==0 && j==this->P.cols()-1){
 	  norm = normal(maxAtU_[i]-delta,maxAtV_[j]) ;
 	  norm += normal(maxAtU_[i],maxAtV_[j]+delta) ;
 	  norm /= T(2) ;
 	  ok = 1 ;
 	}
-	if(i==P.rows()-1 && j==0){
+	if(i==this->P.rows()-1 && j==0){
 	  norm = normal(maxAtU_[i]-delta,maxAtV_[j]) ;
 	  norm += normal(maxAtU_[i],maxAtV_[j]+delta) ;
 	  norm /= T(2) ;
@@ -178,7 +178,7 @@
 	  while(norm.x() == T(0) && 
 	     norm.y() == T(0) &&
 	     norm.z() == T(0)){
-	    if( nt*d >(U[U.n()-1]-U[0])){
+	    if( nt*d >(this->U[this->U.n()-1]-this->U[0])){
 #ifdef USE_EXCEPTION
 	      throw NurbsComputationError();
 #else
@@ -188,12 +188,12 @@
 #endif
 	    }
 	    T u1,u2,v1,v2 ;
-	    if(i==0 || i==P.rows()-1){
+	    if(i==0 || i==this->P.rows()-1){
 	      u1 = u2 = maxAtU_[i] ;
 	      v1 = maxAtV_[j]+ nt*delta ;
 	      v2 = maxAtV_[j]- nt*delta ;
-	      if(v1>V[V.n()-1]) v1 = V[V.n()-1] ;
-	      if(v2<V[0]) v2 = V[0] ;
+	      if(v1>this->V[this->V.n()-1]) v1 = this->V[this->V.n()-1] ;
+	      if(v2<this->V[0]) v2 = this->V[0] ;
 	      norm = normal(u1,v1);
 	      norm += normal(u2,v2) ;
 	      norm /= 2 ; 
@@ -202,8 +202,8 @@
 	      u1 = maxAtU_[i]- nt*delta ;
 	      u2 = maxAtU_[i]+ nt*delta ;
 	      v1 = v2 = maxAtV_[j] ;
-	      if(u1 < U[0]) u1 = U[0] ;
-	      if(u2 > U[U.n()-1]) u2 = U[U.n()-1] ;
+	      if(u1 < this->U[0]) u1 = this->U[0] ;
+	      if(u2 > this->U[this->U.n()-1]) u2 = this->U[this->U.n()-1] ;
 
 	      T u3,v3 ;
 	      u3 = maxAtU_[i] ;
@@ -212,8 +212,8 @@
 	      else
 		v3 = maxAtV_[j]- nt*delta ;
 
-	      if(v3<V[0]) v3 = V[0] ;
-	      if(v3>V[V.n()-1]) v3 = V[V.n()-1] ;
+	      if(v3<this->V[0]) v3 = this->V[0] ;
+	      if(v3>this->V[this->V.n()-1]) v3 = this->V[this->V.n()-1] ;
 
 	      norm = normal(u1,v1);
 	      norm += normal(u2,v2) ;
@@ -263,13 +263,13 @@
 
   int sizeU, sizeV ;
 
-  sizeU = 2*degU+3 ; 
-  if(i-degU-1<0) sizeU += i-degU-1 ; 
-  if(i+degU+1>=P.rows()) sizeU -= i+degU+1-P.rows() ;
-
-  sizeV = 2*degV+3 ;
-  if(j-degV-1<0) sizeV += j-degV-1 ; 
-  if(j+degV+1>=P.cols()) sizeV -= j+degV+1-P.cols() ;
+  sizeU = 2*this->degU+3 ; 
+  if(i-this->degU-1<0) sizeU += i-this->degU-1 ; 
+  if(i+this->degU+1>=this->P.rows()) sizeU -= i+this->degU+1-this->P.rows() ;
+
+  sizeV = 2*this->degV+3 ;
+  if(j-this->degV-1<0) sizeV += j-this->degV-1 ; 
+  if(j+this->degV+1>=this->P.cols()) sizeV -= j+this->degV+1-this->P.cols() ;
   
   Vector<T> u(sizeU) ;
   Vector<T> v(sizeV) ;
@@ -280,16 +280,16 @@
   int n=0;
   int nu = 0 ;
   int nv = 0 ; 
-  for(int k=i-degU-1;k<=i+degU+1;++k){
+  for(int k=i-this->degU-1;k<=i+this->degU+1;++k){
     if(k<0)
       continue ;
-    if(k>=P.rows())
+    if(k>=this->P.rows())
       break ; 
     nv = 0 ;
-    for(int l=j-degV-1;l<=j+degV+1;++l){
+    for(int l=j-this->degV-1;l<=j+this->degV+1;++l){
       if(l<0)
 	continue ;
-      if(l>=P.cols())
+      if(l>=this->P.cols())
 	break ; 
       if( k == i && j==l){
 	pts[n].x() = a.x() ; 
--- nurbs++-3.0.11/nurbs/hnurbsS_sp.cpp.orig	2002-05-13 23:07:46.000000000 +0200
+++ nurbs++-3.0.11/nurbs/hnurbsS_sp.cpp	2006-04-15 14:38:53.156556500 +0200
@@ -43,7 +43,7 @@
 */
 template <class T, int N>
 void HNurbsSurfaceSP<T,N>::updateMaxU() {
-  if(degU>3){
+  if(this->degU>3){
 #ifdef USE_EXCEPTION
     throw NurbsError();
 #else
@@ -53,12 +53,12 @@
 #endif
   }
   else{
-    maxU.resize(P.rows()) ;
-    maxAtU_.resize(P.rows()) ;
-    for(int i=0;i<P.rows();++i){
-      if(!maxInfluence(i,U,degU,maxAtU_[i]))
+    maxU.resize(this->P.rows()) ;
+    maxAtU_.resize(this->P.rows()) ;
+    for(int i=0;i<this->P.rows();++i){
+      if(!maxInfluence(i,this->U,this->degU,maxAtU_[i]))
 	cerr << "Problem in maxInfluence U!\n" ;
-      maxU[i] = nurbsBasisFun(maxAtU_[i],i,degU,U) ;
+      maxU[i] = nurbsBasisFun(maxAtU_[i],i,this->degU,this->U) ;
     }
     
   }
@@ -78,7 +78,7 @@
 */
 template <class T, int N>
 void HNurbsSurfaceSP<T,N>::updateMaxV() {
-  if(degV>3){
+  if(this->degV>3){
 #ifdef USE_EXCEPTION
     throw NurbsError();
 #else
@@ -88,12 +88,12 @@
 #endif
   }
   else{
-    maxV.resize(P.cols()) ;
-    maxAtV_.resize(P.cols()) ;
-    for(int i=0;i<P.cols();++i){
-      if(!maxInfluence(i,V,degV,maxAtV_[i]))
+    maxV.resize(this->P.cols()) ;
+    maxAtV_.resize(this->P.cols()) ;
+    for(int i=0;i<this->P.cols();++i){
+      if(!maxInfluence(i,this->V,this->degV,maxAtV_[i]))
 	cerr << "Problem in maxInfluence V!\n" ;
-      maxV[i] = nurbsBasisFun(maxAtV_[i],i,degV,V) ;
+      maxV[i] = nurbsBasisFun(maxAtV_[i],i,this->degV,this->V) ;
     }
     
   }
@@ -113,18 +113,18 @@
 */
 template <class T, int N>
 void HNurbsSurfaceSP<T,N>::modSurfCPby(int i, int j, const HPoint_nD<T,N>& a) {
-  offset(i,j) +=  a / (maxU[i]*maxV[j]) ; 
-  if(baseLevel_){
+  this->offset(i,j) +=  a / (maxU[i]*maxV[j]) ; 
+  if(this->baseLevel_){
     Point_nD<T,N> vecOffset ; 
-    vecOffset = offset(i,j).x()*ivec(i,j) +
-      offset(i,j).y()*jvec(i,j) +
-      offset(i,j).z()*kvec(i,j) ;
-    P(i,j).x() = baseSurf.ctrlPnts()(i,j).x()+vecOffset.x() ;
-    P(i,j).y() = baseSurf.ctrlPnts()(i,j).y()+vecOffset.y() ;
-    P(i,j).z() = baseSurf.ctrlPnts()(i,j).z()+vecOffset.z() ;
+    vecOffset = this->offset(i,j).x()*this->ivec(i,j) +
+      this->offset(i,j).y()*this->jvec(i,j) +
+      this->offset(i,j).z()*this->kvec(i,j) ;
+    this->P(i,j).x() = this->baseSurf.ctrlPnts()(i,j).x()+vecOffset.x() ;
+    this->P(i,j).y() = this->baseSurf.ctrlPnts()(i,j).y()+vecOffset.y() ;
+    this->P(i,j).z() = this->baseSurf.ctrlPnts()(i,j).z()+vecOffset.z() ;
   }
   else
-    P(i,j) = offset(i,j) ; 
+    this->P(i,j) = this->offset(i,j) ; 
 }
 
 /*!
@@ -151,24 +151,24 @@
 void HNurbsSurfaceSP<T,N>::modOnlySurfCPby(int i, int j, const HPoint_nD<T,N>& a){
   int k ; 
 
-  P = offset ; 
+  this->P = this->offset ; 
 
   // by definition the offset has w = 0 , but this isn't valid for
   // the control points, increasing the w by 1, will generate a valid surface
-  if(baseLevel_)
-    for(k=0;k<P.rows();++k)
-      for(int l=0;l<P.cols();++l)
-	P(k,l).w() += T(1) ; 
+  if(this->baseLevel_)
+    for(k=0;k<this->P.rows();++k)
+      for(int l=0;l<this->P.cols();++l)
+	this->P(k,l).w() += T(1) ; 
 
   int sizeU, sizeV ;
 
-  sizeU = 2*degU+3 ; 
-  if(i-degU-1<0) sizeU += i-degU-1 ; 
-  if(i+degU+1>=P.rows()) sizeU -= i+degU+1-P.rows() ;
-
-  sizeV = 2*degV+3 ;
-  if(j-degV-1<0) sizeV += j-degV-1 ; 
-  if(j+degV+1>=P.cols()) sizeV -= j+degV+1-P.cols() ;
+  sizeU = 2*this->degU+3 ; 
+  if(i-this->degU-1<0) sizeU += i-this->degU-1 ; 
+  if(i+this->degU+1>=this->P.rows()) sizeU -= i+this->degU+1-this->P.rows() ;
+
+  sizeV = 2*this->degV+3 ;
+  if(j-this->degV-1<0) sizeV += j-this->degV-1 ; 
+  if(j+this->degV+1>=this->P.cols()) sizeV -= j+this->degV+1-this->P.cols() ;
   
   Vector<T> u(sizeU) ;
   Vector<T> v(sizeV) ;
@@ -179,16 +179,16 @@
   int n=0;
   int nu = 0 ;
   int nv = 0 ; 
-  for(k=i-degU-1;k<=i+degU+1;++k){
+  for(k=i-this->degU-1;k<=i+this->degU+1;++k){
     if(k<0)
       continue ;
-    if(k>=P.rows())
+    if(k>=this->P.rows())
       break ; 
     nv = 0 ;
-    for(int l=j-degV-1;l<=j+degV+1;++l){
+    for(int l=j-this->degV-1;l<=j+this->degV+1;++l){
       if(l<0)
 	continue ;
-      if(l>=P.cols())
+      if(l>=this->P.cols())
 	break ; 
       if( k == i && j==l){
 	pts[n].x() = a.x() ; 
@@ -216,12 +216,12 @@
   pv.resize(n) ; 
 
   if(NurbsSurface<T,N>::movePoint(u,v,pts,pu,pv)){
-    offset = P ; 
+    this->offset = this->P ; 
     // an offset shouldn't have a weight value.
-    if(baseLevel_)
-      for(k=0;k<P.rows();++k)
-	for(int l=0;l<P.cols();++l)
-	  offset(k,l).w() -= T(1) ; 
+    if(this->baseLevel_)
+      for(k=0;k<this->P.rows();++k)
+	for(int l=0;l<this->P.cols();++l)
+	  this->offset(k,l).w() -= T(1) ; 
   }
   updateSurface(); 
 }
@@ -262,7 +262,7 @@
 HNurbsSurfaceSP<T,N>* HNurbsSurfaceSP<T,N>::addLevel(int n, int s) {
   HNurbsSurfaceSP<T,N> *newLevel ;
 
-  if(nextLevel_)
+  if(this->nextLevel_)
     return 0 ;
 
   Vector<T> newU,newV ;
@@ -289,7 +289,7 @@
 HNurbsSurfaceSP<T,N>* HNurbsSurfaceSP<T,N>::addLevel() {
   HNurbsSurfaceSP<T,N> *newLevel ;
 
-  if(nextLevel_)
+  if(this->nextLevel_)
     return 0 ;
 
   newLevel = new HNurbsSurfaceSP<T,N>(this) ;
@@ -311,23 +311,23 @@
   levelP = nS.nextLevel() ;
 
   NurbsSurface<T,N>::operator=(nS) ;
-  rU = nS.rU ;
-  rV = nS.rV ;
-  offset = nS.offset ;
+  this->rU = nS.rU ;
+  this->rV = nS.rV ;
+  this->offset = nS.offset ;
 
   updateMaxUV() ; 
 
-  firstLevel_ = this ;
+  this->firstLevel_ = this ;
 
   if(levelP){
     HNurbsSurfaceSP<T,N> *newLevel ;
     newLevel =  new HNurbsSurfaceSP<T,N>(this) ; 
     newLevel->copy(*levelP) ;
-    nextLevel_ = newLevel ;
-    lastLevel_ = nextLevel_->lastLevel() ;
+    this->nextLevel_ = newLevel ;
+    this->lastLevel_ = this->nextLevel_->lastLevel() ;
   }
   else{
-    lastLevel_ = this ;
+    this->lastLevel_ = this ;
   }
 
 }
@@ -349,55 +349,55 @@
 template <class T, int N>
 void HNurbsSurfaceSP<T,N>::updateSurface(int i0, int j0){
   if(i0>=0 && j0>=0){
-    if(offset(i0,j0).x()==0.0 && offset(i0,j0).y()==0.0 && offset(i0,j0).z()==0.0)
+    if(this->offset(i0,j0).x()==0.0 && this->offset(i0,j0).y()==0.0 && this->offset(i0,j0).z()==0.0)
       return ;
   }
-  if(baseLevel_){
-    if(initBase()){
-      P = baseSurf.ctrlPnts() ;
-      U = baseSurf.knotU() ;
-      V = baseSurf.knotV() ;
-      degU = baseSurf.degreeU() ;
-      degV = baseSurf.degreeV() ;
+  if(this->baseLevel_){
+    if(this->initBase()){
+      this->P = this->baseSurf.ctrlPnts() ;
+      this->U = this->baseSurf.knotU() ;
+      this->V = this->baseSurf.knotV() ;
+      this->degU = this->baseSurf.degreeU() ;
+      this->degV = this->baseSurf.degreeV() ;
       updateMaxUV() ; 
     }
     if(i0>=0 && j0>=0){
       Point_nD<T,N> vecOffset ;
-      vecOffset = offset(i0,j0).x()*ivec(i0,j0) +
-	offset(i0,j0).y()*jvec(i0,j0) +
-	offset(i0,j0).z()*kvec(i0,j0) ;
-      P(i0,j0).x() = baseSurf.ctrlPnts()(i0,j0).x()+vecOffset.x() ;
-      P(i0,j0).y() = baseSurf.ctrlPnts()(i0,j0).y()+vecOffset.y() ;
-      P(i0,j0).z() = baseSurf.ctrlPnts()(i0,j0).z()+vecOffset.z() ;
+      vecOffset = this->offset(i0,j0).x()*this->ivec(i0,j0) +
+	this->offset(i0,j0).y()*this->jvec(i0,j0) +
+	this->offset(i0,j0).z()*this->kvec(i0,j0) ;
+      this->P(i0,j0).x() = this->baseSurf.ctrlPnts()(i0,j0).x()+vecOffset.x() ;
+      this->P(i0,j0).y() = this->baseSurf.ctrlPnts()(i0,j0).y()+vecOffset.y() ;
+      this->P(i0,j0).z() = this->baseSurf.ctrlPnts()(i0,j0).z()+vecOffset.z() ;
     }
     else{
-      for(int i=0;i<P.rows();++i)
-	for(int j=0;j<P.cols();++j){
-	  if(offset(i,j).x() != 0 || 
-	     offset(i,j).y() != 0 || offset(i,j).z() || 0){
+      for(int i=0;i<this->P.rows();++i)
+	for(int j=0;j<this->P.cols();++j){
+	  if(this->offset(i,j).x() != 0 || 
+	     this->offset(i,j).y() != 0 || this->offset(i,j).z() || 0){
 	    Point_nD<T,N> vecOffset ;
-	    vecOffset = offset(i,j).x()*ivec(i,j) +
-	      offset(i,j).y()*jvec(i,j) +
-	      offset(i,j).z()*kvec(i,j) ;
-	    P(i,j).x() = baseSurf.ctrlPnts()(i,j).x()+vecOffset.x() ;
-	    P(i,j).y() = baseSurf.ctrlPnts()(i,j).y()+vecOffset.y() ;
-	    P(i,j).z() = baseSurf.ctrlPnts()(i,j).z()+vecOffset.z() ;
+	    vecOffset = this->offset(i,j).x()*this->ivec(i,j) +
+	      this->offset(i,j).y()*this->jvec(i,j) +
+	      this->offset(i,j).z()*this->kvec(i,j) ;
+	    this->P(i,j).x() = this->baseSurf.ctrlPnts()(i,j).x()+vecOffset.x() ;
+	    this->P(i,j).y() = this->baseSurf.ctrlPnts()(i,j).y()+vecOffset.y() ;
+	    this->P(i,j).z() = this->baseSurf.ctrlPnts()(i,j).z()+vecOffset.z() ;
 	  }
 	}
     }
   }
   else{
     if(i0>=0 && j0>=0)
-      P(i0,j0) = offset(i0,j0) ;
+      this->P(i0,j0) = this->offset(i0,j0) ;
     else{
-      for(int i=0;i<P.rows();++i)
-	for(int j=0;j<P.cols();++j){
-	  P(i,j) = offset(i,j) ;
+      for(int i=0;i<this->P.rows();++i)
+	for(int j=0;j<this->P.cols();++j){
+	  this->P(i,j) = this->offset(i,j) ;
 	}
     }
   }
 
-  ++updateN ;
+  ++this->updateN ;
 }
 
 /*!
@@ -413,7 +413,7 @@
   if(!okMax())
     updateMaxUV() ; 
   if(upLevel>=0){
-    if(level()<=upLevel){
+    if(this->level()<=upLevel){
       this->updateSurface() ;
     }
   }
@@ -421,9 +421,9 @@
     this->updateSurface() ;
   }
 
-  if(upLevel>level() || upLevel<0){
-    if(nextLevel_)
-      ((HNurbsSurfaceSP<T,N>*)nextLevel_)->updateLevels(upLevel) ;
+  if(upLevel>this->level() || upLevel<0){
+    if(this->nextLevel_)
+      ((HNurbsSurfaceSP<T,N>*)this->nextLevel_)->updateLevels(upLevel) ;
   }
 }
 
@@ -458,10 +458,10 @@
     if(!fin.read((char*)&du,sizeof(int))) { delete []type ; return 0 ;}
     if(!fin.read((char*)&dv,sizeof(int))) { delete []type ; return 0 ;}
     
-    resize(nu,nv,du,dv) ;
+    this->resize(nu,nv,du,dv) ;
     
-    if(!fin.read((char*)U.memory(),sizeof(T)*U.n())) { delete []type ; return 0 ;}
-    if(!fin.read((char*)V.memory(),sizeof(T)*V.n())) { delete []type ; return 0 ;}
+    if(!fin.read((char*)this->U.memory(),sizeof(T)*this->U.n())) { delete []type ; return 0 ;}
+    if(!fin.read((char*)this->V.memory(),sizeof(T)*this->V.n())) { delete []type ; return 0 ;}
     
     if(!r1){
       p = new T[3*nu*nv] ;
@@ -469,10 +469,10 @@
       p2 = p ;
       for(int i=0;i<nu;i++)
 	for(int j=0;j<nv;j++){
-	  P(i,j).x() = *(p++) ;
-	  P(i,j).y() = *(p++) ;
-	  P(i,j).z() = *(p++) ;
-	  P(i,j).w() = 1.0 ;
+	  this->P(i,j).x() = *(p++) ;
+	  this->P(i,j).y() = *(p++) ;
+	  this->P(i,j).z() = *(p++) ;
+	  this->P(i,j).w() = 1.0 ;
 	}
       delete []p2 ;
     }
@@ -482,26 +482,26 @@
       p2 = p ;
       for(int i=0;i<nu;i++)
 	for(int j=0;j<nv;j++){
-	  P(i,j).x() = *(p++) ;
-	  P(i,j).y() = *(p++) ;
-	  P(i,j).z() = *(p++) ;
-	  P(i,j).w() = *(p++) ;
+	  this->P(i,j).x() = *(p++) ;
+	  this->P(i,j).y() = *(p++) ;
+	  this->P(i,j).z() = *(p++) ;
+	  this->P(i,j).w() = *(p++) ;
 	}
       delete []p2 ;
     }
-    offset = P ;
+    this->offset = this->P ;
     this->updateSurface() ;
   }
   else { // reading the offset information
     int ru,rv ;
     if(!fin.read((char*)&ru,sizeof(int))) { delete []type ; return 0 ;}
     if(!fin.read((char*)&rv,sizeof(int))) { delete []type ; return 0 ;}
-    rU.resize(ru) ;
-    rV.resize(rv) ;
-    if(rU.n()>0)
-      if(!fin.read((char*)rU.memory(),sizeof(T)*rU.n())) { delete []type ; return 0 ;}
-    if(rV.n()>0)
-      if(!fin.read((char*)rV.memory(),sizeof(T)*rV.n())) { delete []type ; return 0 ;}
+    this->rU.resize(ru) ;
+    this->rV.resize(rv) ;
+    if(this->rU.n()>0)
+      if(!fin.read((char*)this->rU.memory(),sizeof(T)*this->rU.n())) { delete []type ; return 0 ;}
+    if(HNurbsSurface<T,N>::rV.n()>0)
+      if(!fin.read((char*)this->rV.memory(),sizeof(T)*this->rV.n())) { delete []type ; return 0 ;}
     
     if(!fin.read((char*)&nu,sizeof(int))) { delete []type ; return 0 ;}
     if(!fin.read((char*)&nv,sizeof(int))) { delete []type ; return 0 ;}
@@ -509,16 +509,16 @@
     p = new T[4*nu*nv] ;
     if(!fin.read((char*)p,sizeof(T)*4*nu*nv)) { delete []type ; return 0 ;}
     p2 = p ;
-    offset.resize(nu,nv) ;
+    this->offset.resize(nu,nv) ;
     for(int i=0;i<nu;i++)
       for(int j=0;j<nv;j++){
-	offset(i,j).x() = *(p++) ;
-	offset(i,j).y() = *(p++) ;
-	offset(i,j).z() = *(p++) ;
-	offset(i,j).w() = *(p++) ;
+	this->offset(i,j).x() = *(p++) ;
+	this->offset(i,j).y() = *(p++) ;
+	this->offset(i,j).z() = *(p++) ;
+	this->offset(i,j).w() = *(p++) ;
       }
     delete []p2 ;    
-    --baseUpdateN ;
+    --this->baseUpdateN ;
     this->updateSurface() ;
   }
 
--- nurbs++-3.0.11/nurbs/d_surface.cpp.orig	2002-05-16 18:44:49.000000000 +0200
+++ nurbs++-3.0.11/nurbs/d_surface.cpp	2006-04-15 18:32:55.622155750 +0200
@@ -25,9 +25,6 @@
   template class InterPoint<double,2> ;
   template class InterPoint<double,3> ;
   
-  template class BasicList<InterPoint<double,2> > ; 
-  template class BasicList<InterPoint<double,3> > ; 
-  
   template class ParaSurface<double,2> ;
   template class ParaSurface<double,3> ;
   
@@ -37,3 +34,9 @@
 #endif 
 
 }
+#ifdef NO_IMPLICIT_TEMPLATES
+
+template class BasicList<PLib::InterPoint<double,2> > ; 
+template class BasicList<PLib::InterPoint<double,3> > ; 
+  
+#endif 
--- nurbs++-3.0.11/nurbs/f_surface.cpp.orig	2002-05-16 18:44:49.000000000 +0200
+++ nurbs++-3.0.11/nurbs/f_surface.cpp	2006-04-15 12:25:09.447106000 +0200
@@ -25,9 +25,6 @@
   template class InterPoint<float,2> ;
   template class InterPoint<float,3> ;
   
-  template class BasicList<InterPoint<float,2> > ; 
-  template class BasicList<InterPoint<float,3> > ; 
-  
   template class ParaSurface<float,2> ;
   template class ParaSurface<float,3> ;
   
@@ -38,3 +35,9 @@
 #endif 
 
 }
+#ifdef NO_IMPLICIT_TEMPLATES
+
+template class BasicList<PLib::InterPoint<float,2> > ; 
+template class BasicList<PLib::InterPoint<float,3> > ; 
+
+#endif
--- nurbs++-3.0.11/nurbs/hnurbsS.cpp.orig	2002-05-17 20:24:21.000000000 +0200
+++ nurbs++-3.0.11/nurbs/hnurbsS.cpp	2006-04-15 16:11:07.506431750 +0200
@@ -103,11 +103,11 @@
   initBase() ;
   offset.resize(baseSurf.ctrlPnts()) ;
 
-  P = baseSurf.ctrlPnts() ;
-  U = baseSurf.knotU() ;
-  V = baseSurf.knotV() ;
-  degU = baseSurf.degreeU() ;
-  degV = baseSurf.degreeV() ;
+  this->P = baseSurf.ctrlPnts() ;
+  this->U = baseSurf.knotU() ;
+  this->V = baseSurf.knotV() ;
+  this->degU = baseSurf.degreeU() ;
+  this->degV = baseSurf.degreeV() ;
 
   //updateSurface() ;
 
@@ -162,11 +162,11 @@
   baseUpdateN = baseLevel_->modifiedN()-1 ; // Set it so that initBase will run
   initBase() ;
   offset.resize(baseSurf.ctrlPnts()) ;
-  P = baseSurf.ctrlPnts() ;
-  U = baseSurf.knotU() ;
-  V = baseSurf.knotV() ;
-  degU = baseSurf.degreeU() ;
-  degV = baseSurf.degreeV() ;
+  this->P = baseSurf.ctrlPnts() ;
+  this->U = baseSurf.knotU() ;
+  this->V = baseSurf.knotV() ;
+  this->degU = baseSurf.degreeU() ;
+  this->degV = baseSurf.degreeV() ;
   //updateSurface() ;
 
 }
@@ -200,7 +200,7 @@
   rU.resize(0) ;
   rV.resize(0) ;
 
-  offset = P ;
+  offset = this->P ;
 }
 
 /*!
@@ -334,11 +334,11 @@
   }
   if(baseLevel_){
     if(initBase()){
-      P = baseSurf.ctrlPnts() ;
-      U = baseSurf.knotU() ;
-      V = baseSurf.knotV() ;
-      degU = baseSurf.degreeU() ;
-      degV = baseSurf.degreeV() ;
+      this->P = baseSurf.ctrlPnts() ;
+      this->U = baseSurf.knotU() ;
+      this->V = baseSurf.knotV() ;
+      this->degU = baseSurf.degreeU() ;
+      this->degV = baseSurf.degreeV() ;
     }
     if(i0>=0 && j0>=0){
       Point_nD<T,N> vecOffset ;
@@ -352,13 +352,13 @@
 	  offset(i0,j0).y()*jvec(i0,j0) +
 	  offset(i0,j0).z()*kvec(i0,j0) ;
       }
-      P(i0,j0).x() = baseSurf.ctrlPnts()(i0,j0).x()+vecOffset.x() ;
-      P(i0,j0).y() = baseSurf.ctrlPnts()(i0,j0).y()+vecOffset.y() ;
-      P(i0,j0).z() = baseSurf.ctrlPnts()(i0,j0).z()+vecOffset.z() ;
+      this->P(i0,j0).x() = baseSurf.ctrlPnts()(i0,j0).x()+vecOffset.x() ;
+      this->P(i0,j0).y() = baseSurf.ctrlPnts()(i0,j0).y()+vecOffset.y() ;
+      this->P(i0,j0).z() = baseSurf.ctrlPnts()(i0,j0).z()+vecOffset.z() ;
     }
     else{
-      for(int i=0;i<P.rows();++i)
-	for(int j=0;j<P.cols();++j){
+      for(int i=0;i<this->P.rows();++i)
+	for(int j=0;j<this->P.cols();++j){
 	  if(offset(i,j).x() != 0 || 
 	     offset(i,j).y() != 0 || offset(i,j).z() || 0){
 	    Point_nD<T,N> vecOffset ;
@@ -372,20 +372,20 @@
 		offset(i,j).y()*jvec(i,j) +
 		offset(i,j).z()*kvec(i,j) ;
 	    }
-	    P(i,j).x() = baseSurf.ctrlPnts()(i,j).x()+vecOffset.x() ;
-	    P(i,j).y() = baseSurf.ctrlPnts()(i,j).y()+vecOffset.y() ;
-	    P(i,j).z() = baseSurf.ctrlPnts()(i,j).z()+vecOffset.z() ;
+	    this->P(i,j).x() = baseSurf.ctrlPnts()(i,j).x()+vecOffset.x() ;
+	    this->P(i,j).y() = baseSurf.ctrlPnts()(i,j).y()+vecOffset.y() ;
+	    this->P(i,j).z() = baseSurf.ctrlPnts()(i,j).z()+vecOffset.z() ;
 	  }
 	}
     }
   }
   else{
     if(i0>=0 && j0>=0)
-      P(i0,j0) = offset(i0,j0) ;
+      this->P(i0,j0) = offset(i0,j0) ;
     else{
-      for(int i=0;i<P.rows();++i)
-	for(int j=0;j<P.cols();++j){
-	  P(i,j) = offset(i,j) ;
+      for(int i=0;i<this->P.rows();++i)
+	for(int j=0;j<this->P.cols();++j){
+	  this->P(i,j) = offset(i,j) ;
 	}
     }
   }
@@ -554,17 +554,17 @@
       return mod ;
   }
 
-  if(u<knotU()[0] || u>knotU()[knotU().n()-1])
+  if(u<this->knotU()[0] || u>this->knotU()[this->knotU().n()-1])
     return -1 ;
-  if(v<knotV()[0] || v>knotU()[knotV().n()-1])
+  if(v<this->knotV()[0] || v>this->knotU()[this->knotV().n()-1])
     return -1 ;
 
   int su = findSpanU(u) ;
   int sv = findSpanV(v) ;
 
-  for(int i=0;i<=degU;++i)
-    for(int j=0;j<=degV;++j){
-      if(offset(su-degU+i,sv+degV+j) != HPoint_nD<T,N>(0,0,0,0))
+  for(int i=0;i<=this->degU;++i)
+    for(int j=0;j<=this->degV;++j){
+      if(offset(su-this->degU+i,sv+this->degV+j) != HPoint_nD<T,N>(0,0,0,0))
 	return level_ ;
     }
 
@@ -742,16 +742,16 @@
 template <class T, int N>
 void HNurbsSurface<T,N>::splitUV(int nu, int nv, Vector<T> &nU, Vector<T> &nV){
 
-  nU.resize(knotU().n()*nu) ;
-  nV.resize(knotV().n()*nv) ;
+  nU.resize(this->knotU().n()*nu) ;
+  nV.resize(this->knotV().n()*nv) ;
   
   int i,j,n ;
 
   n = 0 ; 
-  for(i=1;i<knotU().n();++i){
-    if(knotU()[i] >knotU()[i-1]){
-      T a = knotU()[i-1] ;
-      T b = knotU()[i] ;
+  for(i=1;i<this->knotU().n();++i){
+    if(this->knotU()[i] >this->knotU()[i-1]){
+      T a = this->knotU()[i-1] ;
+      T b = this->knotU()[i] ;
 
 
       for(j=0;j<nu;++j){
@@ -763,10 +763,10 @@
   nU.resize(n) ;
 
   n = 0 ;
-  for(i=1;i<knotV().n();++i){
-    if(knotV()[i] > knotV()[i-1]){
-      T a = knotV()[i-1] ;
-      T b = knotV()[i] ;
+  for(i=1;i<this->knotV().n();++i){
+    if(this->knotV()[i] > this->knotV()[i-1]){
+      T a = this->knotV()[i-1] ;
+      T b = this->knotV()[i] ;
 
       for(j=0;j<nv;++j){
 	nV[n] = a + (b-a)*T(j+1)/T(nv+1) ;
@@ -805,22 +805,22 @@
   int i,j,n ;
 
   if(su<=0)
-    su = degU  ;
+    su = this->degU  ;
   if(sv<=0)
-    sv = degV  ;
-  if(su>degU+1)
-    su = degU+1 ;
-  if(sv>degV+1)
-    sv = degV+1 ;
+    sv = this->degV  ;
+  if(su>this->degU+1)
+    su = this->degU+1 ;
+  if(sv>this->degV+1)
+    sv = this->degV+1 ;
 
-  nU.resize(knotU().n()*nu*su) ;
-  nV.resize(knotV().n()*nv*sv) ;
+  nU.resize(this->knotU().n()*nu*su) ;
+  nV.resize(this->knotV().n()*nv*sv) ;
   
   n = 0 ; 
-  for(i=1;i<knotU().n();++i){
-    if(knotU()[i] >knotU()[i-1]){
-      T a = knotU()[i-1] ;
-      T b = knotU()[i] ;
+  for(i=1;i<this->knotU().n();++i){
+    if(this->knotU()[i] >this->knotU()[i-1]){
+      T a = this->knotU()[i-1] ;
+      T b = this->knotU()[i] ;
 
 
       for(j=0;j<nu;++j){
@@ -835,10 +835,10 @@
   nU.resize(n) ;
 
   n = 0 ;
-  for(i=1;i<knotV().n();++i){
-    if(knotV()[i] > knotV()[i-1]){
-      T a = knotV()[i-1] ;
-      T b = knotV()[i] ;
+  for(i=1;i<this->knotV().n();++i){
+    if(this->knotV()[i] > this->knotV()[i-1]){
+      T a = this->knotV()[i-1] ;
+      T b = this->knotV()[i] ;
 
       for(j=0;j<nv;++j){
 	T v = a + (b-a)*T(j+1)/T(nv+1) ;
@@ -1014,10 +1014,10 @@
     if(!fin.read((char*)&du,sizeof(int))) { delete []type ; return 0 ;}
     if(!fin.read((char*)&dv,sizeof(int))) { delete []type ; return 0 ;}
     
-    resize(nu,nv,du,dv) ;
+    this->resize(nu,nv,du,dv) ;
     
-    if(!fin.read((char*)U.memory(),sizeof(T)*U.n())) { delete []type ; return 0 ;}
-    if(!fin.read((char*)V.memory(),sizeof(T)*V.n())) { delete []type ; return 0 ;}
+    if(!fin.read((char*)this->U.memory(),sizeof(T)*this->U.n())) { delete []type ; return 0 ;}
+    if(!fin.read((char*)this->V.memory(),sizeof(T)*this->V.n())) { delete []type ; return 0 ;}
     
     if(!r1){
       p = new T[3*nu*nv] ;
@@ -1025,10 +1025,10 @@
       p2 = p ;
       for(int i=0;i<nu;i++)
 	for(int j=0;j<nv;j++){
-	  P(i,j).x() = *(p++) ;
-	  P(i,j).y() = *(p++) ;
-	  P(i,j).z() = *(p++) ;
-	  P(i,j).w() = 1.0 ;
+	  this->P(i,j).x() = *(p++) ;
+	  this->P(i,j).y() = *(p++) ;
+	  this->P(i,j).z() = *(p++) ;
+	  this->P(i,j).w() = 1.0 ;
 	}
       delete []p2 ;
     }
@@ -1038,14 +1038,14 @@
       p2 = p ;
       for(int i=0;i<nu;i++)
 	for(int j=0;j<nv;j++){
-	  P(i,j).x() = *(p++) ;
-	  P(i,j).y() = *(p++) ;
-	  P(i,j).z() = *(p++) ;
-	  P(i,j).w() = *(p++) ;
+	  this->P(i,j).x() = *(p++) ;
+	  this->P(i,j).y() = *(p++) ;
+	  this->P(i,j).z() = *(p++) ;
+	  this->P(i,j).w() = *(p++) ;
 	}
       delete []p2 ;
     }
-    offset = P ;
+    offset = this->P ;
     this->updateSurface() ;
   }
   else { // reading the offset information
@@ -1144,29 +1144,31 @@
   if(!fout)
     return 0 ;
   if(!baseLevel_){
-    int prows = P.rows();
-    int pcols = P.cols();
+    int prows = this->P.rows();
+    int pcols = this->P.cols();
+    int ndegU = this->degU;
+    int ndegV = this->degV;
     char st = '0' + sizeof(T) ; 
     if(!fout.write((char*)&"hns4",sizeof(char)*4)) return 0 ;
     if(!fout.write((char*)&st,sizeof(char))) return 0 ; 
     if(!fout.write((char*)&prows,sizeof(int))) return 0 ;
     if(!fout.write((char*)&pcols,sizeof(int))) return 0 ;
-    if(!fout.write((char*)&degU,sizeof(int))) return 0 ;
-    if(!fout.write((char*)&degV,sizeof(int))) return 0 ;
-    if(!fout.write((char*)U.memory(),sizeof(T)*U.n())) return 0 ;
-    if(!fout.write((char*)V.memory(),sizeof(T)*V.n())) return 0 ;
+    if(!fout.write((char*)&ndegU,sizeof(int))) return 0 ;
+    if(!fout.write((char*)&ndegV,sizeof(int))) return 0 ;
+    if(!fout.write((char*)this->U.memory(),sizeof(T)*this->U.n())) return 0 ;
+    if(!fout.write((char*)this->V.memory(),sizeof(T)*this->V.n())) return 0 ;
     
     T *p,*p2 ;
-    p = new T[P.rows()*P.cols()*4] ;
+    p = new T[this->P.rows()*this->P.cols()*4] ;
     p2 = p ;
-    for(int i=0;i<P.rows();i++) 
-      for(int j=0;j<P.cols();j++){
+    for(int i=0;i<this->P.rows();i++) 
+      for(int j=0;j<this->P.cols();j++){
 	*p = offset(i,j).x() ; p++ ;
 	*p = offset(i,j).y() ; p++ ;
 	*p = offset(i,j).z() ; p++ ;
 	*p = offset(i,j).w() ; p++ ;
       }
-    if(!fout.write((char*)p2,sizeof(T)*P.rows()*P.cols()*4)) return 0 ;
+    if(!fout.write((char*)p2,sizeof(T)*this->P.rows()*this->P.cols()*4)) return 0 ;
     delete []p2 ;
   }
   else{
@@ -1282,7 +1284,7 @@
   int i,j ;
   j = 0 ;
   for(i=0;i<X.n();++i){
-    if(X[i]>=U[0] && X[i]<=U[U.n()-1]){
+    if(X[i]>=this->U[0] && X[i]<=this->U[this->U.n()-1]){
       Xu[j] = X[i] ;
       ++j ;
     }
@@ -1294,7 +1296,7 @@
       nextLevel_->refineKnotU(Xu) ;
     }
     
-    NurbsSurface<T,N> osurf(degU,degV,U,V,offset) ;
+    NurbsSurface<T,N> osurf(this->degU,this->degV,this->U,this->V,offset) ;
     
     osurf.refineKnotU(Xu) ;
     
@@ -1324,7 +1326,7 @@
   int i,j ;
   j = 0 ;
   for(i=0;i<X.n();++i){
-    if(X[i]>=V[0] && X[i]<=V[V.n()-1]){
+    if(X[i]>=this->V[0] && X[i]<=this->V[this->V.n()-1]){
       Xv[j] = X[i] ;
       ++j ;
     }
@@ -1336,7 +1338,7 @@
       nextLevel_->refineKnotV(Xv) ;
     }
     
-    NurbsSurface<T,N> osurf(degU,degV,U,V,offset) ;
+    NurbsSurface<T,N> osurf(this->degU,this->degV,this->U,this->V,offset) ;
     
     osurf.refineKnotV(Xv) ;
     
@@ -1370,26 +1372,26 @@
 */
 template <class T, int N>
 int HNurbsSurface<T,N>::movePointOffset(T u, T v, const Point_nD<T,N>& delta){
-  P = offset ; 
+  this->P = offset ; 
 
   // by definition the offset has w = 0 , but this isn't valid for
   // the control points, increasing the w by 1, will generate a valid surface
   if(baseLevel_)
-    for(int i=0;i<P.rows();++i)
-      for(int j=0;j<P.cols();++j){
-	P(i,j).w() += T(1) ; 
+    for(int i=0;i<this->P.rows();++i)
+      for(int j=0;j<this->P.cols();++j){
+	this->P(i,j).w() += T(1) ; 
       }
 
   if(NurbsSurface<T,N>::movePoint(u,v,delta)){
-    offset = P ;
+    offset = this->P ;
     // need to reset the offset weights
     if(baseLevel_)
-      for(int i=0;i<P.rows();++i)
-	for(int j=0;j<P.cols();++j){
-	  P(i,j).w() -= T(1) ; 
+      for(int i=0;i<this->P.rows();++i)
+	for(int j=0;j<this->P.cols();++j){
+	  this->P(i,j).w() -= T(1) ; 
       }
     
-    P = baseSurf.ctrlPnts() ; 
+    this->P = baseSurf.ctrlPnts() ; 
     updateSurface() ; 
     return 1 ;
   }
--- nurbs++-3.0.11/nurbs/d_nurbsSub.cpp.orig	2002-05-13 22:11:57.000000000 +0200
+++ nurbs++-3.0.11/nurbs/d_nurbsSub.cpp	2006-04-15 18:37:31.391390250 +0200
@@ -14,7 +14,9 @@
   template class RenderMeshPoints<double> ;
 
   
+  template<>
   double NurbSurface<double>::epsilon = 1e-6 ;
+  template<>
   double SurfSample<double>::epsilon = 1e-6 ;
 
   template void DrawSubdivision( NurbSurface<double> *, double tolerance );
--- nurbs++-3.0.11/nurbs/nurbsGL.cpp.orig	2006-04-18 20:34:19.000000000 +0200
+++ nurbs++-3.0.11/nurbs/nurbsGL.cpp	2006-04-19 16:29:35.000000000 +0200
@@ -27,6 +27,7 @@
 #include <string.h>
 #include <stdio.h>
 #include <iostream.h> 
+#include <ext/mt_allocator.h>
 
 #ifdef WITH_OPENGL
 
@@ -3949,9 +3950,9 @@
 
 template void std::_List_base<PLib::NurbsCurve<float, 2> *, std::allocator<PLib::NurbsCurve<float, 2> *> >::_M_clear(void);
 
-template void __gnu_cxx::__mt_alloc<std::_List_node<PLib::NurbsCurve<float, 2>*>, __gnu_cxx::__common_pool_policy<__gnu_cxx::__pool, true> >::deallocate(std::_List_node<PLib::NurbsCurve<float, 2>*>*, unsigned int);
+template void __gnu_cxx::__mt_alloc<std::_List_node<PLib::NurbsCurve<float, 2>*>, __gnu_cxx::__common_pool_policy<__gnu_cxx::__pool, true> >::deallocate(std::_List_node<PLib::NurbsCurve<float, 2>*>*, std::size_t);
 
-template std::_List_node<PLib::NurbsCurve<float, 2>*>* __gnu_cxx::__mt_alloc<std::_List_node<PLib::NurbsCurve<float, 2>*>, __gnu_cxx::__common_pool_policy<__gnu_cxx::__pool, true> >::allocate(unsigned int, void const*);
+template std::_List_node<PLib::NurbsCurve<float, 2>*>* __gnu_cxx::__mt_alloc<std::_List_node<PLib::NurbsCurve<float, 2>*>, __gnu_cxx::__common_pool_policy<__gnu_cxx::__pool, true> >::allocate(std::size_t, void const*);
 
 #endif
 
